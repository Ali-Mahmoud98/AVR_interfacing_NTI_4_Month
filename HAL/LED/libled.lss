In archive libled.a:

led.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 00000087  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000158  00000000  00000000  000000bb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000175  00000000  00000000  00000213  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .text.led_off 00000020  00000000  00000000  00000388  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.led_on  00000020  00000000  00000000  000003a8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.led_toggle 0000004c  00000000  00000000  000003c8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.led_init 0000006a  00000000  00000000  00000414  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .debug_frame  00000050  00000000  00000000  00000480  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_loc    000000d0  00000000  00000000  000004d0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_pubnames 00000045  00000000  00000000  000005a0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 13 .debug_aranges 00000038  00000000  00000000  000005e5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 14 .debug_ranges 00000030  00000000  00000000  0000061d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 15 .debug_str    00000114  00000000  00000000  0000064d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text.led_off:

00000000 <led_off>:
        break;
    }
}
void led_off(LED led)
{
   switch (led.active_state)
   0:	88 23       	and	r24, r24
   2:	01 f0       	breq	.+0      	; 0x4 <led_off+0x4>
   4:	81 30       	cpi	r24, 0x01	; 1
   6:	01 f4       	brne	.+0      	; 0x8 <led_off+0x8>
    {
    case ACTIVE_HIGH:
        DIO_voidSetPinValue(led.led_port, led.led_pin, LOW);
   8:	86 2f       	mov	r24, r22
   a:	67 2f       	mov	r22, r23
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <led_off>
  12:	08 95       	ret
        break;
    case ACTIVE_LOW:
        DIO_voidSetPinValue(led.led_port, led.led_pin, HIGH);
  14:	86 2f       	mov	r24, r22
  16:	67 2f       	mov	r22, r23
  18:	41 e0       	ldi	r20, 0x01	; 1
  1a:	0e 94 00 00 	call	0	; 0x0 <led_off>
  1e:	08 95       	ret

Disassembly of section .text.led_on:

00000000 <led_on>:
        break;
    }
}
void led_on(LED led)
{
    switch (led.active_state)
   0:	88 23       	and	r24, r24
   2:	01 f0       	breq	.+0      	; 0x4 <led_on+0x4>
   4:	81 30       	cpi	r24, 0x01	; 1
   6:	01 f4       	brne	.+0      	; 0x8 <led_on+0x8>
    {
    case ACTIVE_HIGH:
        DIO_voidSetPinValue(led.led_port, led.led_pin, HIGH);
   8:	86 2f       	mov	r24, r22
   a:	67 2f       	mov	r22, r23
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <led_on>
  12:	08 95       	ret
        break;
    case ACTIVE_LOW:
        DIO_voidSetPinValue(led.led_port, led.led_pin, LOW);
  14:	86 2f       	mov	r24, r22
  16:	67 2f       	mov	r22, r23
  18:	40 e0       	ldi	r20, 0x00	; 0
  1a:	0e 94 00 00 	call	0	; 0x0 <led_on>
  1e:	08 95       	ret

Disassembly of section .text.led_toggle:

00000000 <led_toggle>:
        DIO_voidSetPinValue(led.led_port, led.led_pin, HIGH);
        break;
    } 
}
void led_toggle(LED led)
{
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	f8 2e       	mov	r15, r24
   a:	e9 2e       	mov	r14, r25
   c:	16 2f       	mov	r17, r22
   e:	07 2f       	mov	r16, r23
    if (DIO_voidGetPinValue(led.led_port, led.led_pin) == LOW)
  10:	86 2f       	mov	r24, r22
  12:	67 2f       	mov	r22, r23
  14:	0e 94 00 00 	call	0	; 0x0 <led_toggle>
  18:	88 23       	and	r24, r24
  1a:	01 f4       	brne	.+0      	; 0x1c <led_toggle+0x1c>
    {
        led_on(led);
  1c:	61 2f       	mov	r22, r17
  1e:	70 2f       	mov	r23, r16
  20:	8f 2d       	mov	r24, r15
  22:	9e 2d       	mov	r25, r14
  24:	0e 94 00 00 	call	0	; 0x0 <led_toggle>
  28:	00 c0       	rjmp	.+0      	; 0x2a <led_toggle+0x2a>
    }
    else if (DIO_voidGetPinValue(led.led_port, led.led_pin) == HIGH)
  2a:	81 2f       	mov	r24, r17
  2c:	60 2f       	mov	r22, r16
  2e:	0e 94 00 00 	call	0	; 0x0 <led_toggle>
  32:	81 30       	cpi	r24, 0x01	; 1
  34:	01 f4       	brne	.+0      	; 0x36 <led_toggle+0x36>
    {
        led_off(led);
  36:	61 2f       	mov	r22, r17
  38:	70 2f       	mov	r23, r16
  3a:	8f 2d       	mov	r24, r15
  3c:	9e 2d       	mov	r25, r14
  3e:	0e 94 00 00 	call	0	; 0x0 <led_toggle>
    }
  42:	1f 91       	pop	r17
  44:	0f 91       	pop	r16
  46:	ff 90       	pop	r15
  48:	ef 90       	pop	r14
  4a:	08 95       	ret

Disassembly of section .text.led_init:

00000000 <led_init>:

#include "DIO_Interface.h"


void led_init(LED led)
{
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	08 2f       	mov	r16, r24
   a:	f6 2e       	mov	r15, r22
   c:	e7 2e       	mov	r14, r23
   e:	19 2f       	mov	r17, r25
    /*initialization of led*/
    DIO_voidSetPinDirection(led.led_port, led.led_pin, DIO_u8_OUTPUT);
  10:	86 2f       	mov	r24, r22
  12:	67 2f       	mov	r22, r23
  14:	41 e0       	ldi	r20, 0x01	; 1
  16:	0e 94 00 00 	call	0	; 0x0 <led_init>
    switch (led.active_state)
  1a:	00 23       	and	r16, r16
  1c:	01 f0       	breq	.+0      	; 0x1e <led_init+0x1e>
  1e:	01 30       	cpi	r16, 0x01	; 1
  20:	01 f4       	brne	.+0      	; 0x22 <led_init+0x22>
    {
    case ACTIVE_HIGH:
        switch (led.start_state)
  22:	11 23       	and	r17, r17
  24:	01 f0       	breq	.+0      	; 0x26 <led_init+0x26>
  26:	11 30       	cpi	r17, 0x01	; 1
  28:	01 f4       	brne	.+0      	; 0x2a <led_init+0x2a>
        {
        case HIGH:
            DIO_voidSetPinValue(led.led_port, led.led_pin, HIGH);
  2a:	8f 2d       	mov	r24, r15
  2c:	6e 2d       	mov	r22, r14
  2e:	41 e0       	ldi	r20, 0x01	; 1
  30:	0e 94 00 00 	call	0	; 0x0 <led_init>
  34:	00 c0       	rjmp	.+0      	; 0x36 <led_init+0x36>
            break;
        case LOW:
            DIO_voidSetPinValue(led.led_port, led.led_pin, LOW);
  36:	8f 2d       	mov	r24, r15
  38:	6e 2d       	mov	r22, r14
  3a:	40 e0       	ldi	r20, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <led_init>
  40:	00 c0       	rjmp	.+0      	; 0x42 <led_init+0x42>
            break;
        }
        break;
    case ACTIVE_LOW:
        switch (led.start_state)
  42:	11 23       	and	r17, r17
  44:	01 f0       	breq	.+0      	; 0x46 <led_init+0x46>
  46:	11 30       	cpi	r17, 0x01	; 1
  48:	01 f4       	brne	.+0      	; 0x4a <led_init+0x4a>
        {
        case HIGH:
            DIO_voidSetPinValue(led.led_port, led.led_pin, LOW);
  4a:	8f 2d       	mov	r24, r15
  4c:	6e 2d       	mov	r22, r14
  4e:	40 e0       	ldi	r20, 0x00	; 0
  50:	0e 94 00 00 	call	0	; 0x0 <led_init>
  54:	00 c0       	rjmp	.+0      	; 0x56 <led_init+0x56>
            break;
        case LOW:
            DIO_voidSetPinValue(led.led_port, led.led_pin, HIGH);
  56:	8f 2d       	mov	r24, r15
  58:	6e 2d       	mov	r22, r14
  5a:	41 e0       	ldi	r20, 0x01	; 1
  5c:	0e 94 00 00 	call	0	; 0x0 <led_init>
            break;
        }
        break;
    }
}
  60:	1f 91       	pop	r17
  62:	0f 91       	pop	r16
  64:	ff 90       	pop	r15
  66:	ef 90       	pop	r14
  68:	08 95       	ret
