In archive libkpd.a:

kpd.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 00000122  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000001da  00000000  00000000  00000156  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000288  00000000  00000000  00000330  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .text.KPD_u8GetPressedKey 0000013c  00000000  00000000  000005b8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.KPD_voidInit 0000007a  00000000  00000000  000006f4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .data.KEYPAD_Au8Keys 00000010  00000000  00000000  0000076e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .debug_frame  00000030  00000000  00000000  00000780  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_loc    00000063  00000000  00000000  000007b0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_pubnames 0000004e  00000000  00000000  00000813  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_aranges 00000028  00000000  00000000  00000861  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 13 .debug_ranges 00000068  00000000  00000000  00000889  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 14 .debug_str    000001de  00000000  00000000  000008f1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text.KPD_u8GetPressedKey:

00000000 <KPD_u8GetPressedKey>:
/* I/P Parameters: Nothing									          		    **/
/* Returns:it returns u8	                                				    **/
/* Desc:This Function used to get the value of the pressed key		       	    **/
/*********************************************************************************/
u8 KPD_u8GetPressedKey (void)
{
   0:	3f 92       	push	r3
   2:	4f 92       	push	r4
   4:	5f 92       	push	r5
   6:	6f 92       	push	r6
   8:	7f 92       	push	r7
   a:	8f 92       	push	r8
   c:	9f 92       	push	r9
   e:	af 92       	push	r10
  10:	bf 92       	push	r11
  12:	cf 92       	push	r12
  14:	df 92       	push	r13
  16:	ef 92       	push	r14
  18:	ff 92       	push	r15
  1a:	0f 93       	push	r16
  1c:	1f 93       	push	r17
  1e:	df 93       	push	r29
  20:	cf 93       	push	r28
  22:	cd b7       	in	r28, 0x3d	; 61
  24:	de b7       	in	r29, 0x3e	; 62
  26:	28 97       	sbiw	r28, 0x08	; 8
  28:	0f b6       	in	r0, 0x3f	; 63
  2a:	f8 94       	cli
  2c:	de bf       	out	0x3e, r29	; 62
  2e:	0f be       	out	0x3f, r0	; 63
  30:	cd bf       	out	0x3d, r28	; 61
	   local_u8KeyValue  : the pressed key value in asci ('0' '1' ... '*' '/' ...)
						   initial state =KEYPAD_KEY_NOT_PRESSED = 0xff
	   local_u8Flag      : when a key is pressed flag will be up and the loop will be broken 
						   initially =KEYPAD_u8_FLAG_DOWN; 
	   */
	u8 KEYPAD_Au8RowsPins[KEYPAD_u8_ROW_NUM] = KEYPAD_Au8ROWs;
  32:	95 e0       	ldi	r25, 0x05	; 5
  34:	99 83       	std	Y+1, r25	; 0x01
  36:	84 e0       	ldi	r24, 0x04	; 4
  38:	8a 83       	std	Y+2, r24	; 0x02
  3a:	23 e0       	ldi	r18, 0x03	; 3
  3c:	2b 83       	std	Y+3, r18	; 0x03
  3e:	82 e0       	ldi	r24, 0x02	; 2
  40:	8c 83       	std	Y+4, r24	; 0x04
	u8 KEYPAD_Au8ColsPins[KEYPAD_u8_COL_NUM] = KEYPAD_Au8Cols;
  42:	87 e0       	ldi	r24, 0x07	; 7
  44:	8d 83       	std	Y+5, r24	; 0x05
  46:	86 e0       	ldi	r24, 0x06	; 6
  48:	8e 83       	std	Y+6, r24	; 0x06
  4a:	9f 83       	std	Y+7, r25	; 0x07
  4c:	28 87       	std	Y+8, r18	; 0x08
  4e:	55 24       	eor	r5, r5
  50:	5a 94       	dec	r5
  52:	88 24       	eor	r8, r8
  54:	99 24       	eor	r9, r9
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  56:	00 e9       	ldi	r16, 0x90	; 144
  58:	11 e0       	ldi	r17, 0x01	; 1

	for (local_u8RowCounter=0; local_u8RowCounter < KEYPAD_u8_ROW_NUM; local_u8RowCounter++ )
	{
		DIO_voidSetPinValue(KEYPAD_u8_ROWS_PORT,KEYPAD_Au8RowsPins[local_u8RowCounter],DIO_u8_LOW); //Activate ROw by Setting 0 at output

		for (local_u8ColCounter=0; local_u8ColCounter < KEYPAD_u8_COL_NUM; local_u8ColCounter++)
  5a:	0f 2e       	mov	r0, r31
  5c:	f9 e0       	ldi	r31, 0x09	; 9
  5e:	6f 2e       	mov	r6, r31
  60:	77 24       	eor	r7, r7
  62:	f0 2d       	mov	r31, r0
  64:	6c 0e       	add	r6, r28
  66:	7d 1e       	adc	r7, r29
		{
			if (DIO_voidGetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_Au8ColsPins[local_u8ColCounter]) == KEYPAD_u8_FLAG_DOWN)
  68:	88 ec       	ldi	r24, 0xC8	; 200
  6a:	90 e0       	ldi	r25, 0x00	; 0
  6c:	48 2e       	mov	r4, r24
  6e:	39 2e       	mov	r3, r25
	u8 KEYPAD_Au8RowsPins[KEYPAD_u8_ROW_NUM] = KEYPAD_Au8ROWs;
	u8 KEYPAD_Au8ColsPins[KEYPAD_u8_COL_NUM] = KEYPAD_Au8Cols;

	for (local_u8RowCounter=0; local_u8RowCounter < KEYPAD_u8_ROW_NUM; local_u8RowCounter++ )
	{
		DIO_voidSetPinValue(KEYPAD_u8_ROWS_PORT,KEYPAD_Au8RowsPins[local_u8RowCounter],DIO_u8_LOW); //Activate ROw by Setting 0 at output
  70:	e1 e0       	ldi	r30, 0x01	; 1
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	ec 0f       	add	r30, r28
  76:	fd 1f       	adc	r31, r29
  78:	e8 0d       	add	r30, r8
  7a:	f9 1d       	adc	r31, r9
  7c:	a0 80       	ld	r10, Z
  7e:	82 e0       	ldi	r24, 0x02	; 2
  80:	6a 2d       	mov	r22, r10
  82:	40 e0       	ldi	r20, 0x00	; 0
  84:	0e 94 00 00 	call	0	; 0x0 <KPD_u8GetPressedKey>
  88:	0f 2e       	mov	r0, r31
  8a:	f5 e0       	ldi	r31, 0x05	; 5
  8c:	ef 2e       	mov	r14, r31
  8e:	ff 24       	eor	r15, r15
  90:	f0 2d       	mov	r31, r0
  92:	ec 0e       	add	r14, r28
  94:	fd 1e       	adc	r15, r29
  96:	c4 01       	movw	r24, r8
  98:	88 0f       	add	r24, r24
  9a:	99 1f       	adc	r25, r25
  9c:	88 0f       	add	r24, r24
  9e:	99 1f       	adc	r25, r25
  a0:	0f 2e       	mov	r0, r31
  a2:	f0 e0       	ldi	r31, 0x00	; 0
  a4:	cf 2e       	mov	r12, r31
  a6:	f0 e0       	ldi	r31, 0x00	; 0
  a8:	df 2e       	mov	r13, r31
  aa:	f0 2d       	mov	r31, r0
  ac:	c8 0e       	add	r12, r24
  ae:	d9 1e       	adc	r13, r25

		for (local_u8ColCounter=0; local_u8ColCounter < KEYPAD_u8_COL_NUM; local_u8ColCounter++)
		{
			if (DIO_voidGetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_Au8ColsPins[local_u8ColCounter]) == KEYPAD_u8_FLAG_DOWN)
  b0:	f7 01       	movw	r30, r14
  b2:	b0 80       	ld	r11, Z
  b4:	83 e0       	ldi	r24, 0x03	; 3
  b6:	6b 2d       	mov	r22, r11
  b8:	0e 94 00 00 	call	0	; 0x0 <KPD_u8GetPressedKey>
  bc:	88 23       	and	r24, r24
  be:	01 f4       	brne	.+0      	; 0xc0 <KPD_u8GetPressedKey+0xc0>
  c0:	84 2d       	mov	r24, r4
  c2:	93 2d       	mov	r25, r3
  c4:	f8 01       	movw	r30, r16
  c6:	31 97       	sbiw	r30, 0x01	; 1
  c8:	01 f4       	brne	.+0      	; 0xca <KPD_u8GetPressedKey+0xca>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  ca:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  cc:	01 f4       	brne	.+0      	; 0xce <KPD_u8GetPressedKey+0xce>
			{
				_delay_ms(KEYPAD_u8_DEBOUNCING_MS);
				local_u8KeyValue = KEYPAD_Au8Keys[local_u8RowCounter][local_u8ColCounter];
  ce:	f6 01       	movw	r30, r12
  d0:	50 80       	ld	r5, Z
				while (DIO_voidGetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_Au8ColsPins[local_u8ColCounter]) == KEYPAD_u8_FLAG_DOWN){}
  d2:	83 e0       	ldi	r24, 0x03	; 3
  d4:	6b 2d       	mov	r22, r11
  d6:	0e 94 00 00 	call	0	; 0x0 <KPD_u8GetPressedKey>
  da:	88 23       	and	r24, r24
  dc:	01 f0       	breq	.+0      	; 0xde <KPD_u8GetPressedKey+0xde>
  de:	08 94       	sec
  e0:	e1 1c       	adc	r14, r1
  e2:	f1 1c       	adc	r15, r1
  e4:	08 94       	sec
  e6:	c1 1c       	adc	r12, r1
  e8:	d1 1c       	adc	r13, r1

	for (local_u8RowCounter=0; local_u8RowCounter < KEYPAD_u8_ROW_NUM; local_u8RowCounter++ )
	{
		DIO_voidSetPinValue(KEYPAD_u8_ROWS_PORT,KEYPAD_Au8RowsPins[local_u8RowCounter],DIO_u8_LOW); //Activate ROw by Setting 0 at output

		for (local_u8ColCounter=0; local_u8ColCounter < KEYPAD_u8_COL_NUM; local_u8ColCounter++)
  ea:	e6 14       	cp	r14, r6
  ec:	f7 04       	cpc	r15, r7
  ee:	01 f4       	brne	.+0      	; 0xf0 <KPD_u8GetPressedKey+0xf0>
				local_u8KeyValue = KEYPAD_Au8Keys[local_u8RowCounter][local_u8ColCounter];
				while (DIO_voidGetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_Au8ColsPins[local_u8ColCounter]) == KEYPAD_u8_FLAG_DOWN){}
			}
			
		}
		DIO_voidSetPinValue(KEYPAD_u8_ROWS_PORT,KEYPAD_Au8RowsPins[local_u8RowCounter],DIO_u8_HIGH); //De-Activate column by Setting 1 at output
  f0:	82 e0       	ldi	r24, 0x02	; 2
  f2:	6a 2d       	mov	r22, r10
  f4:	41 e0       	ldi	r20, 0x01	; 1
  f6:	0e 94 00 00 	call	0	; 0x0 <KPD_u8GetPressedKey>
  fa:	08 94       	sec
  fc:	81 1c       	adc	r8, r1
  fe:	91 1c       	adc	r9, r1
						   initially =KEYPAD_u8_FLAG_DOWN; 
	   */
	u8 KEYPAD_Au8RowsPins[KEYPAD_u8_ROW_NUM] = KEYPAD_Au8ROWs;
	u8 KEYPAD_Au8ColsPins[KEYPAD_u8_COL_NUM] = KEYPAD_Au8Cols;

	for (local_u8RowCounter=0; local_u8RowCounter < KEYPAD_u8_ROW_NUM; local_u8RowCounter++ )
 100:	f4 e0       	ldi	r31, 0x04	; 4
 102:	8f 16       	cp	r8, r31
 104:	91 04       	cpc	r9, r1
 106:	01 f0       	breq	.+0      	; 0x108 <KPD_u8GetPressedKey+0x108>
 108:	00 c0       	rjmp	.+0      	; 0x10a <KPD_u8GetPressedKey+0x10a>
		{
			break;
		}
	}
	return local_u8KeyValue;
}
 10a:	85 2d       	mov	r24, r5
 10c:	28 96       	adiw	r28, 0x08	; 8
 10e:	0f b6       	in	r0, 0x3f	; 63
 110:	f8 94       	cli
 112:	de bf       	out	0x3e, r29	; 62
 114:	0f be       	out	0x3f, r0	; 63
 116:	cd bf       	out	0x3d, r28	; 61
 118:	cf 91       	pop	r28
 11a:	df 91       	pop	r29
 11c:	1f 91       	pop	r17
 11e:	0f 91       	pop	r16
 120:	ff 90       	pop	r15
 122:	ef 90       	pop	r14
 124:	df 90       	pop	r13
 126:	cf 90       	pop	r12
 128:	bf 90       	pop	r11
 12a:	af 90       	pop	r10
 12c:	9f 90       	pop	r9
 12e:	8f 90       	pop	r8
 130:	7f 90       	pop	r7
 132:	6f 90       	pop	r6
 134:	5f 90       	pop	r5
 136:	4f 90       	pop	r4
 138:	3f 90       	pop	r3
 13a:	08 95       	ret

Disassembly of section .text.KPD_voidInit:

00000000 <KPD_voidInit>:
/*********************************************************************************/
void KPD_voidInit(void)
{
	/*Set Rows pins to be output & Columns pins to be input*/
	/*ROW pins to be out*/
	DIO_voidSetPinDirection(KEYPAD_u8_ROWS_PORT, KEYPAD_u8_R1_PIN, DIO_u8_OUTPUT);
   0:	82 e0       	ldi	r24, 0x02	; 2
   2:	65 e0       	ldi	r22, 0x05	; 5
   4:	41 e0       	ldi	r20, 0x01	; 1
   6:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinDirection(KEYPAD_u8_ROWS_PORT, KEYPAD_u8_R2_PIN, DIO_u8_OUTPUT);
   a:	82 e0       	ldi	r24, 0x02	; 2
   c:	64 e0       	ldi	r22, 0x04	; 4
   e:	41 e0       	ldi	r20, 0x01	; 1
  10:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinDirection(KEYPAD_u8_ROWS_PORT, KEYPAD_u8_R3_PIN, DIO_u8_OUTPUT);
  14:	82 e0       	ldi	r24, 0x02	; 2
  16:	63 e0       	ldi	r22, 0x03	; 3
  18:	41 e0       	ldi	r20, 0x01	; 1
  1a:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinDirection(KEYPAD_u8_ROWS_PORT, KEYPAD_u8_R4_PIN, DIO_u8_OUTPUT);
  1e:	82 e0       	ldi	r24, 0x02	; 2
  20:	62 e0       	ldi	r22, 0x02	; 2
  22:	41 e0       	ldi	r20, 0x01	; 1
  24:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	/*COL pins input*/
	DIO_voidSetPinDirection(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C1_PIN, DIO_u8_INPUT);
  28:	83 e0       	ldi	r24, 0x03	; 3
  2a:	67 e0       	ldi	r22, 0x07	; 7
  2c:	40 e0       	ldi	r20, 0x00	; 0
  2e:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinDirection(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C2_PIN, DIO_u8_INPUT);
  32:	83 e0       	ldi	r24, 0x03	; 3
  34:	66 e0       	ldi	r22, 0x06	; 6
  36:	40 e0       	ldi	r20, 0x00	; 0
  38:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinDirection(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C3_PIN, DIO_u8_INPUT);
  3c:	83 e0       	ldi	r24, 0x03	; 3
  3e:	65 e0       	ldi	r22, 0x05	; 5
  40:	40 e0       	ldi	r20, 0x00	; 0
  42:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinDirection(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C4_PIN, DIO_u8_INPUT);
  46:	83 e0       	ldi	r24, 0x03	; 3
  48:	63 e0       	ldi	r22, 0x03	; 3
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>

	/*COL PINS to be input PULL UP*/
	DIO_voidSetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C1_PIN, DIO_u8_HIGH);
  50:	83 e0       	ldi	r24, 0x03	; 3
  52:	67 e0       	ldi	r22, 0x07	; 7
  54:	41 e0       	ldi	r20, 0x01	; 1
  56:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C2_PIN, DIO_u8_HIGH);
  5a:	83 e0       	ldi	r24, 0x03	; 3
  5c:	66 e0       	ldi	r22, 0x06	; 6
  5e:	41 e0       	ldi	r20, 0x01	; 1
  60:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C3_PIN, DIO_u8_HIGH);
  64:	83 e0       	ldi	r24, 0x03	; 3
  66:	65 e0       	ldi	r22, 0x05	; 5
  68:	41 e0       	ldi	r20, 0x01	; 1
  6a:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
	DIO_voidSetPinValue(KEYPAD_u8_COLS_PORT, KEYPAD_u8_C4_PIN, DIO_u8_HIGH);
  6e:	83 e0       	ldi	r24, 0x03	; 3
  70:	63 e0       	ldi	r22, 0x03	; 3
  72:	41 e0       	ldi	r20, 0x01	; 1
  74:	0e 94 00 00 	call	0	; 0x0 <KPD_voidInit>
}
  78:	08 95       	ret
