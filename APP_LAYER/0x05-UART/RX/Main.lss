
Main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005d6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  00800060  000005d6  0000064a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .debug_aranges 00000128  00000000  00000000  0000065a  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000242  00000000  00000000  00000782  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000008a3  00000000  00000000  000009c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000388  00000000  00000000  00001267  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000a85  00000000  00000000  000015ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000001d0  00000000  00000000  00002074  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000047a  00000000  00000000  00002244  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000086b  00000000  00000000  000026be  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000108  00000000  00000000  00002f29  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	{
		rev = (rev * 10) + (num % 10);
		num /= 10;
	}
	return rev;
}
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
 *        Valid values are from 0 to 7, corresponding to the pin number in the port.
 * @return An 8-bit unsigned integer representing the value of the specified pin.
 *         The function returns either HIGH (1) or LOW (0) based on the pin's input state.
 */
u8 DIO_voidGetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId)
{
   4:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  // Enable Sending and Recieving by Enabling RXE and TXE bits in USCRB register
  UCSRB = (1 << RXEN) | (1 << TXEN);
}

void UART_voidSendChar(u8 data)
{
   8:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  10:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  14:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  18:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  1c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  20:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  24:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  28:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  2c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  30:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  34:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  38:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  3c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  40:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  44:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  48:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  4c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  50:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 ed       	ldi	r30, 0xD6	; 214
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a0 37       	cpi	r26, 0x70	; 112
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>
  76:	0e 94 41 00 	call	0x82	; 0x82 <main>
  7a:	0c 94 e9 02 	jmp	0x5d2	; 0x5d2 <_exit>

0000007e <__bad_interrupt>:
  7e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000082 <main>:

int main()
{
    u8 rx_data;

    LCD_init();
  82:	0e 94 7e 01 	call	0x2fc	; 0x2fc <LCD_init>
    UART_voidInit();
  86:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <UART_voidInit>

    LCD_displayString_XY(0,2,"Recieved Data:");
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	62 e0       	ldi	r22, 0x02	; 2
  8e:	40 e6       	ldi	r20, 0x60	; 96
  90:	50 e0       	ldi	r21, 0x00	; 0
  92:	0e 94 52 01 	call	0x2a4	; 0x2a4 <LCD_displayString_XY>
    LCD_moveCursor((u8) 1, (u8) 0);
  96:	81 e0       	ldi	r24, 0x01	; 1
  98:	60 e0       	ldi	r22, 0x00	; 0
  9a:	0e 94 2e 01 	call	0x25c	; 0x25c <LCD_moveCursor>
    while (1)
    {
        rx_data = UART_voidGetChar();
  9e:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <UART_voidGetChar>
        LCD_displayCharacter(rx_data);
  a2:	0e 94 6b 00 	call	0xd6	; 0xd6 <LCD_displayCharacter>
  a6:	fb cf       	rjmp	.-10     	; 0x9e <main+0x1c>

000000a8 <LCD_SendFallingEdge>:
 * LCD_SendFallingEdge - Sends a falling edge signal to the LCD module.
 *
 * Note: This function is intended for internal use within the LCD driver and
 * should not be called directly from outside the driver.
 */
static void LCD_SendFallingEdge(){
  a8:	0f 93       	push	r16
  aa:	1f 93       	push	r17
    
    DIO_voidSetPinValue  ( LCD_E_PORT_ID, LCD_E_PIN_ID , HIGH );
  ac:	80 e0       	ldi	r24, 0x00	; 0
  ae:	62 e0       	ldi	r22, 0x02	; 2
  b0:	41 e0       	ldi	r20, 0x01	; 1
  b2:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  b6:	00 ed       	ldi	r16, 0xD0	; 208
  b8:	17 e0       	ldi	r17, 0x07	; 7
  ba:	c8 01       	movw	r24, r16
  bc:	01 97       	sbiw	r24, 0x01	; 1
  be:	f1 f7       	brne	.-4      	; 0xbc <LCD_SendFallingEdge+0x14>
	_delay_ms(1);
	DIO_voidSetPinValue  ( LCD_E_PORT_ID, LCD_E_PIN_ID , LOW  );
  c0:	80 e0       	ldi	r24, 0x00	; 0
  c2:	62 e0       	ldi	r22, 0x02	; 2
  c4:	40 e0       	ldi	r20, 0x00	; 0
  c6:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
  ca:	c8 01       	movw	r24, r16
  cc:	01 97       	sbiw	r24, 0x01	; 1
  ce:	f1 f7       	brne	.-4      	; 0xcc <LCD_SendFallingEdge+0x24>
	_delay_ms(1);
}
  d0:	1f 91       	pop	r17
  d2:	0f 91       	pop	r16
  d4:	08 95       	ret

000000d6 <LCD_displayCharacter>:
 * cursor position.
 *
 * @param data: The character to be displayed on the LCD.
 */
void LCD_displayCharacter(u8 data)
{
  d6:	1f 93       	push	r17
  d8:	18 2f       	mov	r17, r24
	/* sending upper nibble */
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN4, GET_BIT(data, 7));  
  da:	48 2f       	mov	r20, r24
  dc:	44 1f       	adc	r20, r20
  de:	44 27       	eor	r20, r20
  e0:	44 1f       	adc	r20, r20
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	64 e0       	ldi	r22, 0x04	; 4
  e6:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN2, GET_BIT(data, 6));  
  ea:	41 2f       	mov	r20, r17
  ec:	42 95       	swap	r20
  ee:	46 95       	lsr	r20
  f0:	46 95       	lsr	r20
  f2:	43 70       	andi	r20, 0x03	; 3
  f4:	41 70       	andi	r20, 0x01	; 1
  f6:	81 e0       	ldi	r24, 0x01	; 1
  f8:	62 e0       	ldi	r22, 0x02	; 2
  fa:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN1, GET_BIT(data, 5));  
  fe:	41 2f       	mov	r20, r17
 100:	42 95       	swap	r20
 102:	46 95       	lsr	r20
 104:	47 70       	andi	r20, 0x07	; 7
 106:	41 70       	andi	r20, 0x01	; 1
 108:	81 e0       	ldi	r24, 0x01	; 1
 10a:	61 e0       	ldi	r22, 0x01	; 1
 10c:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN0, GET_BIT(data, 4));  
 110:	41 2f       	mov	r20, r17
 112:	42 95       	swap	r20
 114:	4f 70       	andi	r20, 0x0F	; 15
 116:	41 70       	andi	r20, 0x01	; 1
 118:	81 e0       	ldi	r24, 0x01	; 1
 11a:	60 e0       	ldi	r22, 0x00	; 0
 11c:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue  ( LCD_RS_PORT_ID , LCD_RS_PIN_ID , HIGH );		/* RS=1, data reg. */
 120:	80 e0       	ldi	r24, 0x00	; 0
 122:	63 e0       	ldi	r22, 0x03	; 3
 124:	41 e0       	ldi	r20, 0x01	; 1
 126:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	LCD_SendFallingEdge();
 12a:	0e 94 54 00 	call	0xa8	; 0xa8 <LCD_SendFallingEdge>

	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN4, GET_BIT(data, 3));  
 12e:	41 2f       	mov	r20, r17
 130:	46 95       	lsr	r20
 132:	46 95       	lsr	r20
 134:	46 95       	lsr	r20
 136:	41 70       	andi	r20, 0x01	; 1
 138:	81 e0       	ldi	r24, 0x01	; 1
 13a:	64 e0       	ldi	r22, 0x04	; 4
 13c:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN2, GET_BIT(data, 2));  
 140:	41 2f       	mov	r20, r17
 142:	46 95       	lsr	r20
 144:	46 95       	lsr	r20
 146:	41 70       	andi	r20, 0x01	; 1
 148:	81 e0       	ldi	r24, 0x01	; 1
 14a:	62 e0       	ldi	r22, 0x02	; 2
 14c:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN1, GET_BIT(data, 1));  
 150:	41 2f       	mov	r20, r17
 152:	46 95       	lsr	r20
 154:	41 70       	andi	r20, 0x01	; 1
 156:	81 e0       	ldi	r24, 0x01	; 1
 158:	61 e0       	ldi	r22, 0x01	; 1
 15a:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN0, GET_BIT(data, 0)); 
 15e:	11 70       	andi	r17, 0x01	; 1
 160:	81 e0       	ldi	r24, 0x01	; 1
 162:	60 e0       	ldi	r22, 0x00	; 0
 164:	41 2f       	mov	r20, r17
 166:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue  ( LCD_RS_PORT_ID , LCD_RS_PIN_ID , HIGH );		/* RS=1, data reg. */
 16a:	80 e0       	ldi	r24, 0x00	; 0
 16c:	63 e0       	ldi	r22, 0x03	; 3
 16e:	41 e0       	ldi	r20, 0x01	; 1
 170:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	LCD_SendFallingEdge();
 174:	0e 94 54 00 	call	0xa8	; 0xa8 <LCD_SendFallingEdge>
 178:	80 ed       	ldi	r24, 0xD0	; 208
 17a:	97 e0       	ldi	r25, 0x07	; 7
 17c:	01 97       	sbiw	r24, 0x01	; 1
 17e:	f1 f7       	brne	.-4      	; 0x17c <LCD_displayCharacter+0xa6>

	_delay_ms(1);
}
 180:	1f 91       	pop	r17
 182:	08 95       	ret

00000184 <LCD_SendString>:
 *
 * @param str: Pointer to the null-terminated string to be displayed on the LCD.
 *             The string should be no longer than the width of the LCD (usually 20 characters).
 *             Note: The function will not display characters outside the 20-character width.
 */
void LCD_SendString (const char *str){
 184:	1f 93       	push	r17
 186:	cf 93       	push	r28
 188:	df 93       	push	r29
 18a:	ec 01       	movw	r28, r24
    u8 Iterator_u8 = 0 ;

	while( str[Iterator_u8] != '\0' ){
 18c:	88 81       	ld	r24, Y
 18e:	88 23       	and	r24, r24
 190:	51 f0       	breq	.+20     	; 0x1a6 <LCD_SendString+0x22>
 192:	10 e0       	ldi	r17, 0x00	; 0

		LCD_displayCharacter( str[Iterator_u8] );
 194:	0e 94 6b 00 	call	0xd6	; 0xd6 <LCD_displayCharacter>
		Iterator_u8++ ;
 198:	1f 5f       	subi	r17, 0xFF	; 255
 *             Note: The function will not display characters outside the 20-character width.
 */
void LCD_SendString (const char *str){
    u8 Iterator_u8 = 0 ;

	while( str[Iterator_u8] != '\0' ){
 19a:	fe 01       	movw	r30, r28
 19c:	e1 0f       	add	r30, r17
 19e:	f1 1d       	adc	r31, r1
 1a0:	80 81       	ld	r24, Z
 1a2:	88 23       	and	r24, r24
 1a4:	b9 f7       	brne	.-18     	; 0x194 <LCD_SendString+0x10>

		LCD_displayCharacter( str[Iterator_u8] );
		Iterator_u8++ ;
	}
}
 1a6:	df 91       	pop	r29
 1a8:	cf 91       	pop	r28
 1aa:	1f 91       	pop	r17
 1ac:	08 95       	ret

000001ae <LCD_sendCommand>:
 * the cursor position, turning on/off the display, clearing the screen, etc.
 *
 * @param command: The command byte to be sent to the LCD.
 */
void LCD_sendCommand(u8 command)
{
 1ae:	1f 93       	push	r17
 1b0:	18 2f       	mov	r17, r24
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN4, GET_BIT(command, 7));  
 1b2:	48 2f       	mov	r20, r24
 1b4:	44 1f       	adc	r20, r20
 1b6:	44 27       	eor	r20, r20
 1b8:	44 1f       	adc	r20, r20
 1ba:	81 e0       	ldi	r24, 0x01	; 1
 1bc:	64 e0       	ldi	r22, 0x04	; 4
 1be:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN2, GET_BIT(command, 6));  
 1c2:	41 2f       	mov	r20, r17
 1c4:	42 95       	swap	r20
 1c6:	46 95       	lsr	r20
 1c8:	46 95       	lsr	r20
 1ca:	43 70       	andi	r20, 0x03	; 3
 1cc:	41 70       	andi	r20, 0x01	; 1
 1ce:	81 e0       	ldi	r24, 0x01	; 1
 1d0:	62 e0       	ldi	r22, 0x02	; 2
 1d2:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN1, GET_BIT(command, 5));  
 1d6:	41 2f       	mov	r20, r17
 1d8:	42 95       	swap	r20
 1da:	46 95       	lsr	r20
 1dc:	47 70       	andi	r20, 0x07	; 7
 1de:	41 70       	andi	r20, 0x01	; 1
 1e0:	81 e0       	ldi	r24, 0x01	; 1
 1e2:	61 e0       	ldi	r22, 0x01	; 1
 1e4:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN0, GET_BIT(command, 4));  
 1e8:	41 2f       	mov	r20, r17
 1ea:	42 95       	swap	r20
 1ec:	4f 70       	andi	r20, 0x0F	; 15
 1ee:	41 70       	andi	r20, 0x01	; 1
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	60 e0       	ldi	r22, 0x00	; 0
 1f4:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue  ( LCD_RS_PORT_ID , LCD_RS_PIN_ID , LOW );		/* RS=1, data reg. */
 1f8:	80 e0       	ldi	r24, 0x00	; 0
 1fa:	63 e0       	ldi	r22, 0x03	; 3
 1fc:	40 e0       	ldi	r20, 0x00	; 0
 1fe:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	LCD_SendFallingEdge();
 202:	0e 94 54 00 	call	0xa8	; 0xa8 <LCD_SendFallingEdge>

	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN4, GET_BIT(command, 3));  
 206:	41 2f       	mov	r20, r17
 208:	46 95       	lsr	r20
 20a:	46 95       	lsr	r20
 20c:	46 95       	lsr	r20
 20e:	41 70       	andi	r20, 0x01	; 1
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	64 e0       	ldi	r22, 0x04	; 4
 214:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN2, GET_BIT(command, 2));  
 218:	41 2f       	mov	r20, r17
 21a:	46 95       	lsr	r20
 21c:	46 95       	lsr	r20
 21e:	41 70       	andi	r20, 0x01	; 1
 220:	81 e0       	ldi	r24, 0x01	; 1
 222:	62 e0       	ldi	r22, 0x02	; 2
 224:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN1, GET_BIT(command, 1));  
 228:	41 2f       	mov	r20, r17
 22a:	46 95       	lsr	r20
 22c:	41 70       	andi	r20, 0x01	; 1
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	61 e0       	ldi	r22, 0x01	; 1
 232:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN0, GET_BIT(command, 0)); 
 236:	11 70       	andi	r17, 0x01	; 1
 238:	81 e0       	ldi	r24, 0x01	; 1
 23a:	60 e0       	ldi	r22, 0x00	; 0
 23c:	41 2f       	mov	r20, r17
 23e:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	DIO_voidSetPinValue  ( LCD_RS_PORT_ID , LCD_RS_PIN_ID , LOW );		/* RS=1, data reg. */
 242:	80 e0       	ldi	r24, 0x00	; 0
 244:	63 e0       	ldi	r22, 0x03	; 3
 246:	40 e0       	ldi	r20, 0x00	; 0
 248:	0e 94 b0 01 	call	0x360	; 0x360 <DIO_voidSetPinValue>
	LCD_SendFallingEdge();
 24c:	0e 94 54 00 	call	0xa8	; 0xa8 <LCD_SendFallingEdge>
 250:	80 ed       	ldi	r24, 0xD0	; 208
 252:	97 e0       	ldi	r25, 0x07	; 7
 254:	01 97       	sbiw	r24, 0x01	; 1
 256:	f1 f7       	brne	.-4      	; 0x254 <LCD_sendCommand+0xa6>

	_delay_ms(1); /* delay for processing Th = 13ns */

}
 258:	1f 91       	pop	r17
 25a:	08 95       	ret

0000025c <LCD_moveCursor>:
void LCD_moveCursor(u8 row_u8,u8 pos_u8)
{
	if (row_u8 < 0 || pos_u8 < 0)
		return;
	
	if (row_u8 == 0 && pos_u8<20)
 25c:	88 23       	and	r24, r24
 25e:	39 f4       	brne	.+14     	; 0x26e <LCD_moveCursor+0x12>
 260:	64 31       	cpi	r22, 0x14	; 20
 262:	f8 f4       	brcc	.+62     	; 0x2a2 <LCD_moveCursor+0x46>
		LCD_sendCommand((pos_u8 + 0x80));	/* Command of first row and required position<20 */
 264:	86 2f       	mov	r24, r22
 266:	80 58       	subi	r24, 0x80	; 128
 268:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
 26c:	08 95       	ret
	else if (row_u8 == 1 && pos_u8<20)
 26e:	81 30       	cpi	r24, 0x01	; 1
 270:	39 f4       	brne	.+14     	; 0x280 <LCD_moveCursor+0x24>
 272:	64 31       	cpi	r22, 0x14	; 20
 274:	b0 f4       	brcc	.+44     	; 0x2a2 <LCD_moveCursor+0x46>
		LCD_sendCommand((pos_u8 + 0xC0));	/* Command of first row and required position<20 */
 276:	86 2f       	mov	r24, r22
 278:	80 54       	subi	r24, 0x40	; 64
 27a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
 27e:	08 95       	ret
	else if (row_u8 == 2 && pos_u8<20)
 280:	82 30       	cpi	r24, 0x02	; 2
 282:	39 f4       	brne	.+14     	; 0x292 <LCD_moveCursor+0x36>
 284:	64 31       	cpi	r22, 0x14	; 20
 286:	68 f4       	brcc	.+26     	; 0x2a2 <LCD_moveCursor+0x46>
		LCD_sendCommand((pos_u8 + 0x94));	/* Command of first row and required position<20 */
 288:	86 2f       	mov	r24, r22
 28a:	8c 56       	subi	r24, 0x6C	; 108
 28c:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
 290:	08 95       	ret
	else if (row_u8 == 3 && pos_u8<20)
 292:	83 30       	cpi	r24, 0x03	; 3
 294:	31 f4       	brne	.+12     	; 0x2a2 <LCD_moveCursor+0x46>
 296:	64 31       	cpi	r22, 0x14	; 20
 298:	20 f4       	brcc	.+8      	; 0x2a2 <LCD_moveCursor+0x46>
		LCD_sendCommand((pos_u8 + 0xD4));	/* Command of first row and required position<20 */
 29a:	86 2f       	mov	r24, r22
 29c:	8c 52       	subi	r24, 0x2C	; 44
 29e:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
 2a2:	08 95       	ret

000002a4 <LCD_displayString_XY>:
 * @param str: Pointer to the null-terminated string to be displayed on the LCD.
 *             The string should be no longer than the width of the LCD (usually 20 characters).
 *             Note: The function will not display characters outside the 20-character width.
 */
void LCD_displayString_XY(u8 row_u8, u8 pos_u8, const char *str)
{
 2a4:	cf 93       	push	r28
 2a6:	df 93       	push	r29
 2a8:	ea 01       	movw	r28, r20
	if (row_u8 < 0 || pos_u8 < 0)
		return;
	/*send char to location XY*/
	if (row_u8 == 0 && pos_u8<20)
 2aa:	88 23       	and	r24, r24
 2ac:	39 f4       	brne	.+14     	; 0x2bc <LCD_displayString_XY+0x18>
 2ae:	64 31       	cpi	r22, 0x14	; 20
 2b0:	f8 f4       	brcc	.+62     	; 0x2f0 <LCD_displayString_XY+0x4c>
		LCD_sendCommand(pos_u8 + 0x80);	/* Command of first row and required position<20 */
 2b2:	86 2f       	mov	r24, r22
 2b4:	80 58       	subi	r24, 0x80	; 128
 2b6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
 2ba:	1a c0       	rjmp	.+52     	; 0x2f0 <LCD_displayString_XY+0x4c>
	else if (row_u8 == 1 && pos_u8<20)
 2bc:	81 30       	cpi	r24, 0x01	; 1
 2be:	39 f4       	brne	.+14     	; 0x2ce <LCD_displayString_XY+0x2a>
 2c0:	64 31       	cpi	r22, 0x14	; 20
 2c2:	b0 f4       	brcc	.+44     	; 0x2f0 <LCD_displayString_XY+0x4c>
		LCD_sendCommand(pos_u8 + 0xC0);	/* Command of first row and required position<20 */
 2c4:	86 2f       	mov	r24, r22
 2c6:	80 54       	subi	r24, 0x40	; 64
 2c8:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
 2cc:	11 c0       	rjmp	.+34     	; 0x2f0 <LCD_displayString_XY+0x4c>
	else if (row_u8 == 2 && pos_u8<20)
 2ce:	82 30       	cpi	r24, 0x02	; 2
 2d0:	39 f4       	brne	.+14     	; 0x2e0 <LCD_displayString_XY+0x3c>
 2d2:	64 31       	cpi	r22, 0x14	; 20
 2d4:	68 f4       	brcc	.+26     	; 0x2f0 <LCD_displayString_XY+0x4c>
		LCD_sendCommand(pos_u8 + 0x94);	/* Command of first row and required position<20 */
 2d6:	86 2f       	mov	r24, r22
 2d8:	8c 56       	subi	r24, 0x6C	; 108
 2da:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
 2de:	08 c0       	rjmp	.+16     	; 0x2f0 <LCD_displayString_XY+0x4c>
	else if (row_u8 == 3 && pos_u8<20)
 2e0:	83 30       	cpi	r24, 0x03	; 3
 2e2:	31 f4       	brne	.+12     	; 0x2f0 <LCD_displayString_XY+0x4c>
 2e4:	64 31       	cpi	r22, 0x14	; 20
 2e6:	20 f4       	brcc	.+8      	; 0x2f0 <LCD_displayString_XY+0x4c>
		LCD_sendCommand(pos_u8 + 0xD4);	/* Command of first row and required position<20 */
 2e8:	86 2f       	mov	r24, r22
 2ea:	8c 52       	subi	r24, 0x2C	; 44
 2ec:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
	LCD_SendString(str);		/* Call LCD string function */
 2f0:	ce 01       	movw	r24, r28
 2f2:	0e 94 c2 00 	call	0x184	; 0x184 <LCD_SendString>
}
 2f6:	df 91       	pop	r29
 2f8:	cf 91       	pop	r28
 2fa:	08 95       	ret

000002fc <LCD_init>:
 * using the _delay_ms() function or equivalent.
 */
void LCD_init(void)
{
	/* Configure the direction for RS and E pins as output pins */
	DIO_voidSetPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,DIO_u8_OUTPUT);
 2fc:	80 e0       	ldi	r24, 0x00	; 0
 2fe:	63 e0       	ldi	r22, 0x03	; 3
 300:	41 e0       	ldi	r20, 0x01	; 1
 302:	0e 94 44 02 	call	0x488	; 0x488 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_u8_OUTPUT);
 306:	80 e0       	ldi	r24, 0x00	; 0
 308:	62 e0       	ldi	r22, 0x02	; 2
 30a:	41 e0       	ldi	r20, 0x01	; 1
 30c:	0e 94 44 02 	call	0x488	; 0x488 <DIO_voidSetPinDirection>
 310:	80 e4       	ldi	r24, 0x40	; 64
 312:	9c e9       	ldi	r25, 0x9C	; 156
 314:	01 97       	sbiw	r24, 0x01	; 1
 316:	f1 f7       	brne	.-4      	; 0x314 <LCD_init+0x18>

	_delay_ms(20);		/* LCD Power ON delay always > 15ms */


	/* Configure 4 pins in the data port as output pins */
	DIO_voidSetPinDirection(LCD_DATA_PORT_ID, LCD_DB4_PIN_ID, DIO_u8_OUTPUT);
 318:	81 e0       	ldi	r24, 0x01	; 1
 31a:	60 e0       	ldi	r22, 0x00	; 0
 31c:	41 e0       	ldi	r20, 0x01	; 1
 31e:	0e 94 44 02 	call	0x488	; 0x488 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_DATA_PORT_ID, LCD_DB5_PIN_ID, DIO_u8_OUTPUT);
 322:	81 e0       	ldi	r24, 0x01	; 1
 324:	61 e0       	ldi	r22, 0x01	; 1
 326:	41 e0       	ldi	r20, 0x01	; 1
 328:	0e 94 44 02 	call	0x488	; 0x488 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_DATA_PORT_ID, LCD_DB6_PIN_ID, DIO_u8_OUTPUT);
 32c:	81 e0       	ldi	r24, 0x01	; 1
 32e:	62 e0       	ldi	r22, 0x02	; 2
 330:	41 e0       	ldi	r20, 0x01	; 1
 332:	0e 94 44 02 	call	0x488	; 0x488 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_DATA_PORT_ID, LCD_DB7_PIN_ID, DIO_u8_OUTPUT);
 336:	81 e0       	ldi	r24, 0x01	; 1
 338:	64 e0       	ldi	r22, 0x04	; 4
 33a:	41 e0       	ldi	r20, 0x01	; 1
 33c:	0e 94 44 02 	call	0x488	; 0x488 <DIO_voidSetPinDirection>

	/* Send for 4 bit initialization of LCD  */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT1);
 340:	83 e3       	ldi	r24, 0x33	; 51
 342:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT2);
 346:	82 e3       	ldi	r24, 0x32	; 50
 348:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>

	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);
 34c:	88 e2       	ldi	r24, 0x28	; 40
 34e:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>


	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
 352:	8c e0       	ldi	r24, 0x0C	; 12
 354:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
 358:	81 e0       	ldi	r24, 0x01	; 1
 35a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <LCD_sendCommand>

}
 35e:	08 95       	ret

00000360 <DIO_voidSetPinValue>:
 * @return None.
 */
void DIO_voidSetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8Value)
{
    
    if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PortId >= DIO_u8_PORTA) && (Copy_u8PinId <= DIO_u8_PIN7) && (Copy_u8PinId >= DIO_u8_PIN0))
 360:	84 30       	cpi	r24, 0x04	; 4
 362:	08 f0       	brcs	.+2      	; 0x366 <DIO_voidSetPinValue+0x6>
 364:	90 c0       	rjmp	.+288    	; 0x486 <DIO_voidSetPinValue+0x126>
 366:	68 30       	cpi	r22, 0x08	; 8
 368:	08 f0       	brcs	.+2      	; 0x36c <DIO_voidSetPinValue+0xc>
 36a:	8d c0       	rjmp	.+282    	; 0x486 <DIO_voidSetPinValue+0x126>
    {
        switch(Copy_u8PortId)   
 36c:	81 30       	cpi	r24, 0x01	; 1
 36e:	51 f1       	breq	.+84     	; 0x3c4 <DIO_voidSetPinValue+0x64>
 370:	81 30       	cpi	r24, 0x01	; 1
 372:	38 f0       	brcs	.+14     	; 0x382 <DIO_voidSetPinValue+0x22>
 374:	82 30       	cpi	r24, 0x02	; 2
 376:	09 f4       	brne	.+2      	; 0x37a <DIO_voidSetPinValue+0x1a>
 378:	46 c0       	rjmp	.+140    	; 0x406 <DIO_voidSetPinValue+0xa6>
 37a:	83 30       	cpi	r24, 0x03	; 3
 37c:	09 f0       	breq	.+2      	; 0x380 <DIO_voidSetPinValue+0x20>
 37e:	83 c0       	rjmp	.+262    	; 0x486 <DIO_voidSetPinValue+0x126>
 380:	63 c0       	rjmp	.+198    	; 0x448 <DIO_voidSetPinValue+0xe8>
        {
            case DIO_u8_PORTA:  switch(Copy_u8Value)    
 382:	44 23       	and	r20, r20
 384:	21 f0       	breq	.+8      	; 0x38e <DIO_voidSetPinValue+0x2e>
 386:	41 30       	cpi	r20, 0x01	; 1
 388:	09 f0       	breq	.+2      	; 0x38c <DIO_voidSetPinValue+0x2c>
 38a:	7d c0       	rjmp	.+250    	; 0x486 <DIO_voidSetPinValue+0x126>
 38c:	0e c0       	rjmp	.+28     	; 0x3aa <DIO_voidSetPinValue+0x4a>
                                {
                                    case  DIO_u8_LOW:   CLR_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);     break;  
 38e:	eb e3       	ldi	r30, 0x3B	; 59
 390:	f0 e0       	ldi	r31, 0x00	; 0
 392:	20 81       	ld	r18, Z
 394:	81 e0       	ldi	r24, 0x01	; 1
 396:	90 e0       	ldi	r25, 0x00	; 0
 398:	02 c0       	rjmp	.+4      	; 0x39e <DIO_voidSetPinValue+0x3e>
 39a:	88 0f       	add	r24, r24
 39c:	99 1f       	adc	r25, r25
 39e:	6a 95       	dec	r22
 3a0:	e2 f7       	brpl	.-8      	; 0x39a <DIO_voidSetPinValue+0x3a>
 3a2:	80 95       	com	r24
 3a4:	82 23       	and	r24, r18
 3a6:	80 83       	st	Z, r24
 3a8:	08 95       	ret
                                    case  DIO_u8_HIGH:  SET_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);     break;   
 3aa:	eb e3       	ldi	r30, 0x3B	; 59
 3ac:	f0 e0       	ldi	r31, 0x00	; 0
 3ae:	20 81       	ld	r18, Z
 3b0:	81 e0       	ldi	r24, 0x01	; 1
 3b2:	90 e0       	ldi	r25, 0x00	; 0
 3b4:	02 c0       	rjmp	.+4      	; 0x3ba <DIO_voidSetPinValue+0x5a>
 3b6:	88 0f       	add	r24, r24
 3b8:	99 1f       	adc	r25, r25
 3ba:	6a 95       	dec	r22
 3bc:	e2 f7       	brpl	.-8      	; 0x3b6 <DIO_voidSetPinValue+0x56>
 3be:	28 2b       	or	r18, r24
 3c0:	20 83       	st	Z, r18
 3c2:	08 95       	ret
                                }                            
                                break;
            case DIO_u8_PORTB:  switch(Copy_u8Value)
 3c4:	44 23       	and	r20, r20
 3c6:	21 f0       	breq	.+8      	; 0x3d0 <DIO_voidSetPinValue+0x70>
 3c8:	41 30       	cpi	r20, 0x01	; 1
 3ca:	09 f0       	breq	.+2      	; 0x3ce <DIO_voidSetPinValue+0x6e>
 3cc:	5c c0       	rjmp	.+184    	; 0x486 <DIO_voidSetPinValue+0x126>
 3ce:	0e c0       	rjmp	.+28     	; 0x3ec <DIO_voidSetPinValue+0x8c>
                                {       
                                    case  DIO_u8_LOW:   CLR_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);     break;
 3d0:	e8 e3       	ldi	r30, 0x38	; 56
 3d2:	f0 e0       	ldi	r31, 0x00	; 0
 3d4:	20 81       	ld	r18, Z
 3d6:	81 e0       	ldi	r24, 0x01	; 1
 3d8:	90 e0       	ldi	r25, 0x00	; 0
 3da:	02 c0       	rjmp	.+4      	; 0x3e0 <DIO_voidSetPinValue+0x80>
 3dc:	88 0f       	add	r24, r24
 3de:	99 1f       	adc	r25, r25
 3e0:	6a 95       	dec	r22
 3e2:	e2 f7       	brpl	.-8      	; 0x3dc <DIO_voidSetPinValue+0x7c>
 3e4:	80 95       	com	r24
 3e6:	82 23       	and	r24, r18
 3e8:	80 83       	st	Z, r24
 3ea:	08 95       	ret
                                    case  DIO_u8_HIGH:  SET_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);     break;
 3ec:	e8 e3       	ldi	r30, 0x38	; 56
 3ee:	f0 e0       	ldi	r31, 0x00	; 0
 3f0:	20 81       	ld	r18, Z
 3f2:	81 e0       	ldi	r24, 0x01	; 1
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	02 c0       	rjmp	.+4      	; 0x3fc <DIO_voidSetPinValue+0x9c>
 3f8:	88 0f       	add	r24, r24
 3fa:	99 1f       	adc	r25, r25
 3fc:	6a 95       	dec	r22
 3fe:	e2 f7       	brpl	.-8      	; 0x3f8 <DIO_voidSetPinValue+0x98>
 400:	28 2b       	or	r18, r24
 402:	20 83       	st	Z, r18
 404:	08 95       	ret
                                }                            
                                break;
            case DIO_u8_PORTC:  switch(Copy_u8Value)
 406:	44 23       	and	r20, r20
 408:	21 f0       	breq	.+8      	; 0x412 <DIO_voidSetPinValue+0xb2>
 40a:	41 30       	cpi	r20, 0x01	; 1
 40c:	09 f0       	breq	.+2      	; 0x410 <DIO_voidSetPinValue+0xb0>
 40e:	3b c0       	rjmp	.+118    	; 0x486 <DIO_voidSetPinValue+0x126>
 410:	0e c0       	rjmp	.+28     	; 0x42e <DIO_voidSetPinValue+0xce>
                                {
                                    case  DIO_u8_LOW:   CLR_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);     break;
 412:	e5 e3       	ldi	r30, 0x35	; 53
 414:	f0 e0       	ldi	r31, 0x00	; 0
 416:	20 81       	ld	r18, Z
 418:	81 e0       	ldi	r24, 0x01	; 1
 41a:	90 e0       	ldi	r25, 0x00	; 0
 41c:	02 c0       	rjmp	.+4      	; 0x422 <DIO_voidSetPinValue+0xc2>
 41e:	88 0f       	add	r24, r24
 420:	99 1f       	adc	r25, r25
 422:	6a 95       	dec	r22
 424:	e2 f7       	brpl	.-8      	; 0x41e <DIO_voidSetPinValue+0xbe>
 426:	80 95       	com	r24
 428:	82 23       	and	r24, r18
 42a:	80 83       	st	Z, r24
 42c:	08 95       	ret
                                    case  DIO_u8_HIGH:  SET_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);     break;
 42e:	e5 e3       	ldi	r30, 0x35	; 53
 430:	f0 e0       	ldi	r31, 0x00	; 0
 432:	20 81       	ld	r18, Z
 434:	81 e0       	ldi	r24, 0x01	; 1
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	02 c0       	rjmp	.+4      	; 0x43e <DIO_voidSetPinValue+0xde>
 43a:	88 0f       	add	r24, r24
 43c:	99 1f       	adc	r25, r25
 43e:	6a 95       	dec	r22
 440:	e2 f7       	brpl	.-8      	; 0x43a <DIO_voidSetPinValue+0xda>
 442:	28 2b       	or	r18, r24
 444:	20 83       	st	Z, r18
 446:	08 95       	ret
                                }                            
                                break;
            case DIO_u8_PORTD:  switch(Copy_u8Value)
 448:	44 23       	and	r20, r20
 44a:	19 f0       	breq	.+6      	; 0x452 <DIO_voidSetPinValue+0xf2>
 44c:	41 30       	cpi	r20, 0x01	; 1
 44e:	d9 f4       	brne	.+54     	; 0x486 <DIO_voidSetPinValue+0x126>
 450:	0e c0       	rjmp	.+28     	; 0x46e <DIO_voidSetPinValue+0x10e>
                                {
                                    case  DIO_u8_LOW:   CLR_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);     break;
 452:	e2 e3       	ldi	r30, 0x32	; 50
 454:	f0 e0       	ldi	r31, 0x00	; 0
 456:	20 81       	ld	r18, Z
 458:	81 e0       	ldi	r24, 0x01	; 1
 45a:	90 e0       	ldi	r25, 0x00	; 0
 45c:	02 c0       	rjmp	.+4      	; 0x462 <DIO_voidSetPinValue+0x102>
 45e:	88 0f       	add	r24, r24
 460:	99 1f       	adc	r25, r25
 462:	6a 95       	dec	r22
 464:	e2 f7       	brpl	.-8      	; 0x45e <DIO_voidSetPinValue+0xfe>
 466:	80 95       	com	r24
 468:	82 23       	and	r24, r18
 46a:	80 83       	st	Z, r24
 46c:	08 95       	ret
                                    case  DIO_u8_HIGH:  SET_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);     break;
 46e:	e2 e3       	ldi	r30, 0x32	; 50
 470:	f0 e0       	ldi	r31, 0x00	; 0
 472:	20 81       	ld	r18, Z
 474:	81 e0       	ldi	r24, 0x01	; 1
 476:	90 e0       	ldi	r25, 0x00	; 0
 478:	02 c0       	rjmp	.+4      	; 0x47e <DIO_voidSetPinValue+0x11e>
 47a:	88 0f       	add	r24, r24
 47c:	99 1f       	adc	r25, r25
 47e:	6a 95       	dec	r22
 480:	e2 f7       	brpl	.-8      	; 0x47a <DIO_voidSetPinValue+0x11a>
 482:	28 2b       	or	r18, r24
 484:	20 83       	st	Z, r18
 486:	08 95       	ret

00000488 <DIO_voidSetPinDirection>:
 * @return None.
 */
void DIO_voidSetPinDirection(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8Direction)
{
    
    if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PortId >= DIO_u8_PORTA) && (Copy_u8PinId <= DIO_u8_PIN7) && (Copy_u8PinId >= DIO_u8_PIN0))
 488:	84 30       	cpi	r24, 0x04	; 4
 48a:	08 f0       	brcs	.+2      	; 0x48e <DIO_voidSetPinDirection+0x6>
 48c:	90 c0       	rjmp	.+288    	; 0x5ae <DIO_voidSetPinDirection+0x126>
 48e:	68 30       	cpi	r22, 0x08	; 8
 490:	08 f0       	brcs	.+2      	; 0x494 <DIO_voidSetPinDirection+0xc>
 492:	8d c0       	rjmp	.+282    	; 0x5ae <DIO_voidSetPinDirection+0x126>
    {
        switch(Copy_u8PortId)   
 494:	81 30       	cpi	r24, 0x01	; 1
 496:	51 f1       	breq	.+84     	; 0x4ec <DIO_voidSetPinDirection+0x64>
 498:	81 30       	cpi	r24, 0x01	; 1
 49a:	38 f0       	brcs	.+14     	; 0x4aa <DIO_voidSetPinDirection+0x22>
 49c:	82 30       	cpi	r24, 0x02	; 2
 49e:	09 f4       	brne	.+2      	; 0x4a2 <DIO_voidSetPinDirection+0x1a>
 4a0:	46 c0       	rjmp	.+140    	; 0x52e <DIO_voidSetPinDirection+0xa6>
 4a2:	83 30       	cpi	r24, 0x03	; 3
 4a4:	09 f0       	breq	.+2      	; 0x4a8 <DIO_voidSetPinDirection+0x20>
 4a6:	83 c0       	rjmp	.+262    	; 0x5ae <DIO_voidSetPinDirection+0x126>
 4a8:	63 c0       	rjmp	.+198    	; 0x570 <DIO_voidSetPinDirection+0xe8>
        {
            case DIO_u8_PORTA:  switch(Copy_u8Direction)    
 4aa:	44 23       	and	r20, r20
 4ac:	21 f0       	breq	.+8      	; 0x4b6 <DIO_voidSetPinDirection+0x2e>
 4ae:	41 30       	cpi	r20, 0x01	; 1
 4b0:	09 f0       	breq	.+2      	; 0x4b4 <DIO_voidSetPinDirection+0x2c>
 4b2:	7d c0       	rjmp	.+250    	; 0x5ae <DIO_voidSetPinDirection+0x126>
 4b4:	0e c0       	rjmp	.+28     	; 0x4d2 <DIO_voidSetPinDirection+0x4a>
                                {
                                    case  DIO_u8_INPUT:   CLR_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);     break;  
 4b6:	ea e3       	ldi	r30, 0x3A	; 58
 4b8:	f0 e0       	ldi	r31, 0x00	; 0
 4ba:	20 81       	ld	r18, Z
 4bc:	81 e0       	ldi	r24, 0x01	; 1
 4be:	90 e0       	ldi	r25, 0x00	; 0
 4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <DIO_voidSetPinDirection+0x3e>
 4c2:	88 0f       	add	r24, r24
 4c4:	99 1f       	adc	r25, r25
 4c6:	6a 95       	dec	r22
 4c8:	e2 f7       	brpl	.-8      	; 0x4c2 <DIO_voidSetPinDirection+0x3a>
 4ca:	80 95       	com	r24
 4cc:	82 23       	and	r24, r18
 4ce:	80 83       	st	Z, r24
 4d0:	08 95       	ret
                                    case  DIO_u8_OUTPUT:  SET_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);     break;   
 4d2:	ea e3       	ldi	r30, 0x3A	; 58
 4d4:	f0 e0       	ldi	r31, 0x00	; 0
 4d6:	20 81       	ld	r18, Z
 4d8:	81 e0       	ldi	r24, 0x01	; 1
 4da:	90 e0       	ldi	r25, 0x00	; 0
 4dc:	02 c0       	rjmp	.+4      	; 0x4e2 <DIO_voidSetPinDirection+0x5a>
 4de:	88 0f       	add	r24, r24
 4e0:	99 1f       	adc	r25, r25
 4e2:	6a 95       	dec	r22
 4e4:	e2 f7       	brpl	.-8      	; 0x4de <DIO_voidSetPinDirection+0x56>
 4e6:	28 2b       	or	r18, r24
 4e8:	20 83       	st	Z, r18
 4ea:	08 95       	ret
                                }                            
                                break;
            case DIO_u8_PORTB:  switch(Copy_u8Direction)
 4ec:	44 23       	and	r20, r20
 4ee:	21 f0       	breq	.+8      	; 0x4f8 <DIO_voidSetPinDirection+0x70>
 4f0:	41 30       	cpi	r20, 0x01	; 1
 4f2:	09 f0       	breq	.+2      	; 0x4f6 <DIO_voidSetPinDirection+0x6e>
 4f4:	5c c0       	rjmp	.+184    	; 0x5ae <DIO_voidSetPinDirection+0x126>
 4f6:	0e c0       	rjmp	.+28     	; 0x514 <DIO_voidSetPinDirection+0x8c>
                                {       
                                    case  DIO_u8_INPUT:   CLR_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);     break;
 4f8:	e7 e3       	ldi	r30, 0x37	; 55
 4fa:	f0 e0       	ldi	r31, 0x00	; 0
 4fc:	20 81       	ld	r18, Z
 4fe:	81 e0       	ldi	r24, 0x01	; 1
 500:	90 e0       	ldi	r25, 0x00	; 0
 502:	02 c0       	rjmp	.+4      	; 0x508 <DIO_voidSetPinDirection+0x80>
 504:	88 0f       	add	r24, r24
 506:	99 1f       	adc	r25, r25
 508:	6a 95       	dec	r22
 50a:	e2 f7       	brpl	.-8      	; 0x504 <DIO_voidSetPinDirection+0x7c>
 50c:	80 95       	com	r24
 50e:	82 23       	and	r24, r18
 510:	80 83       	st	Z, r24
 512:	08 95       	ret
                                    case  DIO_u8_OUTPUT:  SET_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);     break;
 514:	e7 e3       	ldi	r30, 0x37	; 55
 516:	f0 e0       	ldi	r31, 0x00	; 0
 518:	20 81       	ld	r18, Z
 51a:	81 e0       	ldi	r24, 0x01	; 1
 51c:	90 e0       	ldi	r25, 0x00	; 0
 51e:	02 c0       	rjmp	.+4      	; 0x524 <DIO_voidSetPinDirection+0x9c>
 520:	88 0f       	add	r24, r24
 522:	99 1f       	adc	r25, r25
 524:	6a 95       	dec	r22
 526:	e2 f7       	brpl	.-8      	; 0x520 <DIO_voidSetPinDirection+0x98>
 528:	28 2b       	or	r18, r24
 52a:	20 83       	st	Z, r18
 52c:	08 95       	ret
                                }                            
                                break;
            case DIO_u8_PORTC:  switch(Copy_u8Direction)
 52e:	44 23       	and	r20, r20
 530:	21 f0       	breq	.+8      	; 0x53a <DIO_voidSetPinDirection+0xb2>
 532:	41 30       	cpi	r20, 0x01	; 1
 534:	09 f0       	breq	.+2      	; 0x538 <DIO_voidSetPinDirection+0xb0>
 536:	3b c0       	rjmp	.+118    	; 0x5ae <DIO_voidSetPinDirection+0x126>
 538:	0e c0       	rjmp	.+28     	; 0x556 <DIO_voidSetPinDirection+0xce>
                                {
                                    case  DIO_u8_INPUT:   CLR_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);     break;
 53a:	e4 e3       	ldi	r30, 0x34	; 52
 53c:	f0 e0       	ldi	r31, 0x00	; 0
 53e:	20 81       	ld	r18, Z
 540:	81 e0       	ldi	r24, 0x01	; 1
 542:	90 e0       	ldi	r25, 0x00	; 0
 544:	02 c0       	rjmp	.+4      	; 0x54a <DIO_voidSetPinDirection+0xc2>
 546:	88 0f       	add	r24, r24
 548:	99 1f       	adc	r25, r25
 54a:	6a 95       	dec	r22
 54c:	e2 f7       	brpl	.-8      	; 0x546 <DIO_voidSetPinDirection+0xbe>
 54e:	80 95       	com	r24
 550:	82 23       	and	r24, r18
 552:	80 83       	st	Z, r24
 554:	08 95       	ret
                                    case  DIO_u8_OUTPUT:  SET_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);     break;
 556:	e4 e3       	ldi	r30, 0x34	; 52
 558:	f0 e0       	ldi	r31, 0x00	; 0
 55a:	20 81       	ld	r18, Z
 55c:	81 e0       	ldi	r24, 0x01	; 1
 55e:	90 e0       	ldi	r25, 0x00	; 0
 560:	02 c0       	rjmp	.+4      	; 0x566 <DIO_voidSetPinDirection+0xde>
 562:	88 0f       	add	r24, r24
 564:	99 1f       	adc	r25, r25
 566:	6a 95       	dec	r22
 568:	e2 f7       	brpl	.-8      	; 0x562 <DIO_voidSetPinDirection+0xda>
 56a:	28 2b       	or	r18, r24
 56c:	20 83       	st	Z, r18
 56e:	08 95       	ret
                                }                            
                                break;
            case DIO_u8_PORTD:  switch(Copy_u8Direction)
 570:	44 23       	and	r20, r20
 572:	19 f0       	breq	.+6      	; 0x57a <DIO_voidSetPinDirection+0xf2>
 574:	41 30       	cpi	r20, 0x01	; 1
 576:	d9 f4       	brne	.+54     	; 0x5ae <DIO_voidSetPinDirection+0x126>
 578:	0e c0       	rjmp	.+28     	; 0x596 <DIO_voidSetPinDirection+0x10e>
                                {
                                    case  DIO_u8_INPUT:   CLR_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);     break;
 57a:	e1 e3       	ldi	r30, 0x31	; 49
 57c:	f0 e0       	ldi	r31, 0x00	; 0
 57e:	20 81       	ld	r18, Z
 580:	81 e0       	ldi	r24, 0x01	; 1
 582:	90 e0       	ldi	r25, 0x00	; 0
 584:	02 c0       	rjmp	.+4      	; 0x58a <DIO_voidSetPinDirection+0x102>
 586:	88 0f       	add	r24, r24
 588:	99 1f       	adc	r25, r25
 58a:	6a 95       	dec	r22
 58c:	e2 f7       	brpl	.-8      	; 0x586 <DIO_voidSetPinDirection+0xfe>
 58e:	80 95       	com	r24
 590:	82 23       	and	r24, r18
 592:	80 83       	st	Z, r24
 594:	08 95       	ret
                                    case  DIO_u8_OUTPUT:  SET_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);     break;
 596:	e1 e3       	ldi	r30, 0x31	; 49
 598:	f0 e0       	ldi	r31, 0x00	; 0
 59a:	20 81       	ld	r18, Z
 59c:	81 e0       	ldi	r24, 0x01	; 1
 59e:	90 e0       	ldi	r25, 0x00	; 0
 5a0:	02 c0       	rjmp	.+4      	; 0x5a6 <DIO_voidSetPinDirection+0x11e>
 5a2:	88 0f       	add	r24, r24
 5a4:	99 1f       	adc	r25, r25
 5a6:	6a 95       	dec	r22
 5a8:	e2 f7       	brpl	.-8      	; 0x5a2 <DIO_voidSetPinDirection+0x11a>
 5aa:	28 2b       	or	r18, r24
 5ac:	20 83       	st	Z, r18
 5ae:	08 95       	ret

000005b0 <UART_voidInit>:

void UART_voidInit(void)
{
	/* PUT SOME CODE HERE */
  // Set BaudRate -> 9600 or whatever
  UBRRL = BAUD_PRESCALE;		/* Load lower 8-bits of the baud rate value */
 5b0:	83 e3       	ldi	r24, 0x33	; 51
 5b2:	89 b9       	out	0x09, r24	; 9
	UBRRH = (BAUD_PRESCALE >> 8);	/* Load upper 8-bits*/
 5b4:	e0 e4       	ldi	r30, 0x40	; 64
 5b6:	f0 e0       	ldi	r31, 0x00	; 0
 5b8:	10 82       	st	Z, r1
  // Set Frame Format -> 8 data, 1 stop, No Parity or what ever
  UCSRC = (1 << URSEL) | (1 << UCSZ1) | (1 << UCSZ0);
 5ba:	86 e8       	ldi	r24, 0x86	; 134
 5bc:	80 83       	st	Z, r24
  // Enable Sending and Recieving by Enabling RXE and TXE bits in USCRB register
  UCSRB = (1 << RXEN) | (1 << TXEN);
 5be:	88 e1       	ldi	r24, 0x18	; 24
 5c0:	8a b9       	out	0x0a, r24	; 10
}
 5c2:	08 95       	ret

000005c4 <UART_voidGetChar>:

u8 UART_voidGetChar(void)
{
  u8 data;
  // wait for the receiving flag (RXC bit in UCSRA register)
  while ((UCSRA & (1 << RXC)) == 0);/* Wait till data is received */
 5c4:	eb e2       	ldi	r30, 0x2B	; 43
 5c6:	f0 e0       	ldi	r31, 0x00	; 0
 5c8:	80 81       	ld	r24, Z
 5ca:	88 23       	and	r24, r24
 5cc:	ec f7       	brge	.-6      	; 0x5c8 <UART_voidGetChar+0x4>
  //read data
	data = UDR_R;
 5ce:	8c b1       	in	r24, 0x0c	; 12

  return data;
  
}
 5d0:	08 95       	ret

000005d2 <_exit>:
 5d2:	f8 94       	cli

000005d4 <__stop_program>:
 5d4:	ff cf       	rjmp	.-2      	; 0x5d4 <__stop_program>
