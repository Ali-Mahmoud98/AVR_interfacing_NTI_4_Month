In archive libuart.a:

uart.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 000000bf  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000142  00000000  00000000  000000f3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000153  00000000  00000000  00000235  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .text.UART_voidInit 00000014  00000000  00000000  00000388  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.UART_voidSendChar 00000010  00000000  00000000  0000039c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.UART_voidGetChar 0000000e  00000000  00000000  000003ac  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.UART_voidGetString 0000000a  00000000  00000000  000003ba  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.UART_voidSendString 0000002a  00000000  00000000  000003c4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .debug_frame  00000060  00000000  00000000  000003f0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_loc    00000084  00000000  00000000  00000450  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 13 .debug_pubnames 0000007e  00000000  00000000  000004d4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 14 .debug_aranges 00000040  00000000  00000000  00000552  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 15 .debug_ranges 00000038  00000000  00000000  00000592  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 16 .debug_str    00000126  00000000  00000000  000005ca  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text.UART_voidInit:

00000000 <UART_voidInit>:

void UART_voidInit(void)
{
	/* PUT SOME CODE HERE */
  // Set BaudRate -> 9600 or whatever
  UBRRL = BAUD_PRESCALE;		/* Load lower 8-bits of the baud rate value */
   0:	83 e3       	ldi	r24, 0x33	; 51
   2:	89 b9       	out	0x09, r24	; 9
	UBRRH = (BAUD_PRESCALE >> 8);	/* Load upper 8-bits*/
   4:	e0 e4       	ldi	r30, 0x40	; 64
   6:	f0 e0       	ldi	r31, 0x00	; 0
   8:	10 82       	st	Z, r1
  // Set Frame Format -> 8 data, 1 stop, No Parity or what ever
  UCSRC = (1 << URSEL) | (1 << UCSZ1) | (1 << UCSZ0);
   a:	86 e8       	ldi	r24, 0x86	; 134
   c:	80 83       	st	Z, r24
  // Enable Sending and Recieving by Enabling RXE and TXE bits in USCRB register
  UCSRB = (1 << RXEN) | (1 << TXEN);
   e:	88 e1       	ldi	r24, 0x18	; 24
  10:	8a b9       	out	0x0a, r24	; 10
}
  12:	08 95       	ret

Disassembly of section .text.UART_voidSendChar:

00000000 <UART_voidSendChar>:

void UART_voidSendChar(u8 data)
{
   0:	98 2f       	mov	r25, r24
  // wait for the trasmitting flag (UDRE bit in UCSRA register)
  while (! (UCSRA & (1<<UDRE)));
   2:	eb e2       	ldi	r30, 0x2B	; 43
   4:	f0 e0       	ldi	r31, 0x00	; 0
   6:	80 81       	ld	r24, Z
   8:	85 ff       	sbrs	r24, 5
   a:	00 c0       	rjmp	.+0      	; 0xc <UART_voidSendChar+0xc>
	//send data
  UDR_T = data;
   c:	9c b9       	out	0x0c, r25	; 12
}
   e:	08 95       	ret

Disassembly of section .text.UART_voidGetChar:

00000000 <UART_voidGetChar>:

u8 UART_voidGetChar(void)
{
  u8 data;
  // wait for the receiving flag (RXC bit in UCSRA register)
  while ((UCSRA & (1 << RXC)) == 0);/* Wait till data is received */
   0:	eb e2       	ldi	r30, 0x2B	; 43
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	88 23       	and	r24, r24
   8:	04 f4       	brge	.+0      	; 0xa <UART_voidGetChar+0xa>
  //read data
	data = UDR_R;
   a:	8c b1       	in	r24, 0x0c	; 12

  return data;
  
}
   c:	08 95       	ret

Disassembly of section .text.UART_voidGetString:

00000000 <UART_voidGetString>:

void UART_voidGetString(u8* str)
{
	while (UART_voidGetChar() != '\0'){}
   0:	0e 94 00 00 	call	0	; 0x0 <UART_voidGetString>
   4:	88 23       	and	r24, r24
   6:	01 f4       	brne	.+0      	; 0x8 <UART_voidGetString+0x8>
}
   8:	08 95       	ret

Disassembly of section .text.UART_voidSendString:

00000000 <UART_voidSendString>:

void UART_voidSendString(const u8* str)
{
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
  u8 j=0;
	while (str[j] != '\0')
   8:	88 81       	ld	r24, Y
   a:	88 23       	and	r24, r24
   c:	01 f0       	breq	.+0      	; 0xe <UART_voidSendString+0xe>
   e:	10 e0       	ldi	r17, 0x00	; 0
	{
		UART_voidSendChar(str[j]);	
  10:	0e 94 00 00 	call	0	; 0x0 <UART_voidSendString>
		j++;
  14:	1f 5f       	subi	r17, 0xFF	; 255
}

void UART_voidSendString(const u8* str)
{
  u8 j=0;
	while (str[j] != '\0')
  16:	fe 01       	movw	r30, r28
  18:	e1 0f       	add	r30, r17
  1a:	f1 1d       	adc	r31, r1
  1c:	80 81       	ld	r24, Z
  1e:	88 23       	and	r24, r24
  20:	01 f4       	brne	.+0      	; 0x22 <UART_voidSendString+0x22>
	{
		UART_voidSendChar(str[j]);	
		j++;
	}
}
  22:	df 91       	pop	r29
  24:	cf 91       	pop	r28
  26:	1f 91       	pop	r17
  28:	08 95       	ret
