In archive libtimer.a:

timer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003ec  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000420  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  00000000  00000000  00000420  2**0
                  ALLOC
  3 .stab         000009e4  00000000  00000000  00000420  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000009bb  00000000  00000000  00000e04  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <timer0_void_init>:
        TCCR0->FOC0 = 1;
        /*set output mode*/
        TCCR0->compare_match_mode = OUT_MODE_COMPARE;

    #elif TIMER0_MODE == FAST_PWM
        TCCR0->WGM00 = 1;
   0:	83 b7       	in	r24, 0x33	; 51
   2:	80 64       	ori	r24, 0x40	; 64
   4:	83 bf       	out	0x33, r24	; 51
        TCCR0->WGM01 = 1;
   6:	83 b7       	in	r24, 0x33	; 51
   8:	88 60       	ori	r24, 0x08	; 8
   a:	83 bf       	out	0x33, r24	; 51
        TCCR0->FOC0 = 0;
   c:	83 b7       	in	r24, 0x33	; 51
   e:	8f 77       	andi	r24, 0x7F	; 127
  10:	83 bf       	out	0x33, r24	; 51
        /*set output mode*/
        TCCR0->compare_match_mode = COMPARE_OUT_MODE_PWM;
  12:	83 b7       	in	r24, 0x33	; 51
  14:	8f 7c       	andi	r24, 0xCF	; 207
  16:	83 bf       	out	0x33, r24	; 51

    #endif
    TCCR0->clock_select = CLOCK_SELECT;
  18:	83 b7       	in	r24, 0x33	; 51
  1a:	88 7f       	andi	r24, 0xF8	; 248
  1c:	85 60       	ori	r24, 0x05	; 5
  1e:	83 bf       	out	0x33, r24	; 51
}
  20:	08 95       	ret

00000022 <TIMER0_voidSetPreload>:
 * @param CompMatch The compare match mode (0 or 1) to set the preload value for.
 * @param Preload_Value The value to preload into Timer0.
 */
void TIMER0_voidSetPreload (u8 CompMatch,u8 Preload_Value)
{
	OCR0 = CompMatch;
  22:	8c bf       	out	0x3c, r24	; 60
	TCNT0 = Preload_Value;
  24:	62 bf       	out	0x32, r22	; 50
}
  26:	08 95       	ret

00000028 <timer0_void_off>:
/**
 * Turns off Timer0.
 */
void timer0_void_off(void)
{
    TCCR0->clock_select = 0;
  28:	83 b7       	in	r24, 0x33	; 51
  2a:	88 7f       	andi	r24, 0xF8	; 248
  2c:	83 bf       	out	0x33, r24	; 51
}
  2e:	08 95       	ret

00000030 <Timer0_set_preLoadVal>:
/**
 * Turns off Timer0.
 */
void Timer0_set_preLoadVal(u8 val)
{
    TCNT0 = val;
  30:	82 bf       	out	0x32, r24	; 50
}
  32:	08 95       	ret

00000034 <timer0_Interrupt_OverFlow_Enable>:
/**
 * Enables Timer0 overflow interrupts.
 */
void timer0_Interrupt_OverFlow_Enable(void)
{
    SET_BIT(TIMSK, TOIE0);
  34:	89 b7       	in	r24, 0x39	; 57
  36:	81 60       	ori	r24, 0x01	; 1
  38:	89 bf       	out	0x39, r24	; 57
}
  3a:	08 95       	ret

0000003c <timer0_Interrupt_CompMatch_Enable>:
/**
 * Enables Timer0 compare match interrupts.
 */
void timer0_Interrupt_CompMatch_Enable(void)
{
    SET_BIT(TIMSK, OCIE0);
  3c:	89 b7       	in	r24, 0x39	; 57
  3e:	82 60       	ori	r24, 0x02	; 2
  40:	89 bf       	out	0x39, r24	; 57
}
  42:	08 95       	ret

00000044 <timer0_Interrupt_OverFlow_Disable>:
/**
 * Disable Timer0 overflow interrupts.
 */
void timer0_Interrupt_OverFlow_Disable(void)
{
    CLR_BIT(TIMSK, TOIE0);
  44:	89 b7       	in	r24, 0x39	; 57
  46:	8e 7f       	andi	r24, 0xFE	; 254
  48:	89 bf       	out	0x39, r24	; 57
}
  4a:	08 95       	ret

0000004c <timer0_Interrupt_CompMatch_Disable>:
/**
 * Disable Timer0 compare match interrupts.
 */
void timer0_Interrupt_CompMatch_Disable(void)
{
    CLR_BIT(TIMSK, OCIE0);
  4c:	89 b7       	in	r24, 0x39	; 57
  4e:	8d 7f       	andi	r24, 0xFD	; 253
  50:	89 bf       	out	0x39, r24	; 57
}
  52:	08 95       	ret

00000054 <set_OCR0Val>:
 *
 * @param ocr0Val The value to be set in OCR0.
 */
void set_OCR0Val(u8 ocr0Val)
{
    OCR0 = ocr0Val;
  54:	8c bf       	out	0x3c, r24	; 60
}
  56:	08 95       	ret

00000058 <timer0_Interrupt_FlagClear>:
/**
 * Clears Timer0 interrupt flags.
 */
void timer0_Interrupt_FlagClear(void)
{
    SET_BIT(TIFR, TOV0);
  58:	88 b7       	in	r24, 0x38	; 56
  5a:	81 60       	ori	r24, 0x01	; 1
  5c:	88 bf       	out	0x38, r24	; 56
}
  5e:	08 95       	ret

00000060 <timer0_Interrupt_CompMatch_FlagClear>:
/**
 * Clears Timer0 compare match interrupt flag.
 */
void timer0_Interrupt_CompMatch_FlagClear(void)
{
    SET_BIT(TIFR, OCF0);
  60:	88 b7       	in	r24, 0x38	; 56
  62:	82 60       	ori	r24, 0x02	; 2
  64:	88 bf       	out	0x38, r24	; 56
}
  66:	08 95       	ret

00000068 <TIMER0_voidPWM>:
    #if COMPARE_OUT_MODE_PWM == SET_OC0
	OCR0 = (u8)(255 - ( ((f32) Duty_Cycle / 100) * 255));
	#elif COMPARE_OUT_MODE_PWM == CLEAR_OC0
	OCR0 = (u8)(((f32) Duty_Cycle / 100) * 256);
    #endif
}
  68:	08 95       	ret

0000006a <init_void_timer1>:
 * @param CMP_MODE Compare match mode for Timer1.
 * @param PRESCALER Prescaler value for Timer1.
 */
void init_void_timer1(u8 WFGM_MODE, u8 CMP_MODE, u8 PRESCALER)
{
    switch (WFGM_MODE)
  6a:	88 23       	and	r24, r24
  6c:	01 f4       	brne	.+0      	; 0x6e <init_void_timer1+0x4>
    {
    case NORMAL_M:
        TCCR1A->WGM = 0;
  6e:	8f b5       	in	r24, 0x2f	; 47
  70:	8c 7f       	andi	r24, 0xFC	; 252
  72:	8f bd       	out	0x2f, r24	; 47
        CLR_BIT(TCCR1B, WGM12);
  74:	8e b5       	in	r24, 0x2e	; 46
  76:	87 7f       	andi	r24, 0xF7	; 247
  78:	8e bd       	out	0x2e, r24	; 46
        CLR_BIT(TCCR1B, WGM13);
  7a:	8e b5       	in	r24, 0x2e	; 46
  7c:	8f 7e       	andi	r24, 0xEF	; 239
  7e:	8e bd       	out	0x2e, r24	; 46
        TCCR1A->COMP1A = NORMAL_OP;
  80:	8f b5       	in	r24, 0x2f	; 47
  82:	8f 7b       	andi	r24, 0xBF	; 191
  84:	8f bd       	out	0x2f, r24	; 47
        TCCR1A->COMP1B = NORMAL_OP;
  86:	8f b5       	in	r24, 0x2f	; 47
  88:	8f 7c       	andi	r24, 0xCF	; 207
  8a:	8f bd       	out	0x2f, r24	; 47
        break;
    default:
        break;
    }
    switch (PRESCALER)
  8c:	43 30       	cpi	r20, 0x03	; 3
  8e:	01 f0       	breq	.+0      	; 0x90 <init_void_timer1+0x26>
  90:	44 30       	cpi	r20, 0x04	; 4
  92:	00 f4       	brcc	.+0      	; 0x94 <init_void_timer1+0x2a>
  94:	41 30       	cpi	r20, 0x01	; 1
  96:	01 f0       	breq	.+0      	; 0x98 <init_void_timer1+0x2e>
  98:	42 30       	cpi	r20, 0x02	; 2
  9a:	00 f4       	brcc	.+0      	; 0x9c <init_void_timer1+0x32>
  9c:	00 c0       	rjmp	.+0      	; 0x9e <init_void_timer1+0x34>
  9e:	45 30       	cpi	r20, 0x05	; 5
  a0:	01 f0       	breq	.+0      	; 0xa2 <init_void_timer1+0x38>
  a2:	45 30       	cpi	r20, 0x05	; 5
  a4:	00 f0       	brcs	.+0      	; 0xa6 <init_void_timer1+0x3c>
  a6:	46 30       	cpi	r20, 0x06	; 6
  a8:	01 f0       	breq	.+0      	; 0xaa <init_void_timer1+0x40>
  aa:	47 30       	cpi	r20, 0x07	; 7
  ac:	01 f4       	brne	.+0      	; 0xae <init_void_timer1+0x44>
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <init_void_timer1+0x46>
    {
    case NO_CLOCK:
        CLR_BIT(TCCR1B, 0);
  b0:	8e b5       	in	r24, 0x2e	; 46
  b2:	8e 7f       	andi	r24, 0xFE	; 254
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <init_void_timer1+0x4c>
        CLR_BIT(TCCR1B, 1);
        CLR_BIT(TCCR1B, 2);
        break;
    case CLOCK_1:
        SET_BIT(TCCR1B, 0);
  b6:	8e b5       	in	r24, 0x2e	; 46
  b8:	81 60       	ori	r24, 0x01	; 1
  ba:	8e bd       	out	0x2e, r24	; 46
        CLR_BIT(TCCR1B, 1);
  bc:	8e b5       	in	r24, 0x2e	; 46
  be:	8d 7f       	andi	r24, 0xFD	; 253
  c0:	8e bd       	out	0x2e, r24	; 46
        CLR_BIT(TCCR1B, 2);
  c2:	8e b5       	in	r24, 0x2e	; 46
  c4:	8b 7f       	andi	r24, 0xFB	; 251
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <init_void_timer1+0x5e>
        break;
    case CLOCK_8:
        CLR_BIT(TCCR1B, 0);
  c8:	8e b5       	in	r24, 0x2e	; 46
  ca:	8e 7f       	andi	r24, 0xFE	; 254
  cc:	00 c0       	rjmp	.+0      	; 0xce <init_void_timer1+0x64>
        SET_BIT(TCCR1B, 1);
        CLR_BIT(TCCR1B, 2);
        break;
    case CLOCK_64:
        SET_BIT(TCCR1B, 0);
  ce:	8e b5       	in	r24, 0x2e	; 46
  d0:	81 60       	ori	r24, 0x01	; 1
  d2:	8e bd       	out	0x2e, r24	; 46
        SET_BIT(TCCR1B, 1);
  d4:	8e b5       	in	r24, 0x2e	; 46
  d6:	82 60       	ori	r24, 0x02	; 2
  d8:	00 c0       	rjmp	.+0      	; 0xda <init_void_timer1+0x70>
        CLR_BIT(TCCR1B, 2);
        break;
    case CLOCK_256:
        CLR_BIT(TCCR1B, 0);
  da:	8e b5       	in	r24, 0x2e	; 46
  dc:	8e 7f       	andi	r24, 0xFE	; 254
  de:	00 c0       	rjmp	.+0      	; 0xe0 <init_void_timer1+0x76>
        CLR_BIT(TCCR1B, 1);
        SET_BIT(TCCR1B, 2);
        break;
    case CLOCK_1024:
        SET_BIT(TCCR1B, 0);
  e0:	8e b5       	in	r24, 0x2e	; 46
  e2:	81 60       	ori	r24, 0x01	; 1
  e4:	8e bd       	out	0x2e, r24	; 46
        CLR_BIT(TCCR1B, 1);
  e6:	8e b5       	in	r24, 0x2e	; 46
  e8:	8d 7f       	andi	r24, 0xFD	; 253
  ea:	00 c0       	rjmp	.+0      	; 0xec <init_void_timer1+0x82>
        SET_BIT(TCCR1B, 2);
        break;
    case CLOCK_EXT_FALLING:
        CLR_BIT(TCCR1B, 0);
  ec:	8e b5       	in	r24, 0x2e	; 46
  ee:	8e 7f       	andi	r24, 0xFE	; 254
  f0:	8e bd       	out	0x2e, r24	; 46
        SET_BIT(TCCR1B, 1);
  f2:	8e b5       	in	r24, 0x2e	; 46
  f4:	82 60       	ori	r24, 0x02	; 2
  f6:	8e bd       	out	0x2e, r24	; 46
        SET_BIT(TCCR1B, 2);
  f8:	8e b5       	in	r24, 0x2e	; 46
  fa:	84 60       	ori	r24, 0x04	; 4
  fc:	8e bd       	out	0x2e, r24	; 46
  fe:	08 95       	ret
        break;
    case CLOCK_EXT_RISING:
        SET_BIT(TCCR1B, 0);
 100:	8e b5       	in	r24, 0x2e	; 46
 102:	81 60       	ori	r24, 0x01	; 1
 104:	8e bd       	out	0x2e, r24	; 46
        SET_BIT(TCCR1B, 1);
 106:	8e b5       	in	r24, 0x2e	; 46
 108:	82 60       	ori	r24, 0x02	; 2
 10a:	8e bd       	out	0x2e, r24	; 46
        SET_BIT(TCCR1B, 2);
 10c:	8e b5       	in	r24, 0x2e	; 46
 10e:	84 60       	ori	r24, 0x04	; 4
 110:	8e bd       	out	0x2e, r24	; 46
 112:	08 95       	ret

00000114 <timer1_interrupt_ENABLE>:
    }
}
 
void timer1_interrupt_ENABLE(void)
{
    SET_BIT(TIMSK ,TOIE1);
 114:	89 b7       	in	r24, 0x39	; 57
 116:	84 60       	ori	r24, 0x04	; 4
 118:	89 bf       	out	0x39, r24	; 57
}
 11a:	08 95       	ret

0000011c <timer1_CMPA_Inerrupt_EN>:

void timer1_CMPA_Inerrupt_EN(void)
{
    SET_BIT(TIMSK, OCF1A);
 11c:	89 b7       	in	r24, 0x39	; 57
 11e:	80 61       	ori	r24, 0x10	; 16
 120:	89 bf       	out	0x39, r24	; 57
}
 122:	08 95       	ret

00000124 <timer1_CMPB_Inerrupt_EN>:

void timer1_CMPB_Inerrupt_EN(void)
{
    SET_BIT(TIMSK, OCF1B);
 124:	89 b7       	in	r24, 0x39	; 57
 126:	88 60       	ori	r24, 0x08	; 8
 128:	89 bf       	out	0x39, r24	; 57
}
 12a:	08 95       	ret

0000012c <setCallBack_OV_T0>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer0 overflow interrupt.
 */
void setCallBack_OV_T0(void (*ptr2fun)(void))
{
    overFlowCallB_T0 = ptr2fun;
 12c:	90 93 00 00 	sts	0x0000, r25
 130:	80 93 00 00 	sts	0x0000, r24
}
 134:	08 95       	ret

00000136 <setCallBack_CMP_T0>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer0 compare match interrupt.
 */
void setCallBack_CMP_T0(void (*ptr2fun)(void))
{
    cmpMatchCallB_T0 = ptr2fun;
 136:	90 93 00 00 	sts	0x0000, r25
 13a:	80 93 00 00 	sts	0x0000, r24
}
 13e:	08 95       	ret

00000140 <setCallBack_CEVENT_T1>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer1 compare match A interrupt.
 */
void setCallBack_CEVENT_T1(void (*ptr2fun)(void))
{
    cmpMatchCallB_T1_CEVENT = ptr2fun;
 140:	90 93 00 00 	sts	0x0000, r25
 144:	80 93 00 00 	sts	0x0000, r24
}
 148:	08 95       	ret

0000014a <setCallBack_CMPA_T1>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer1 compare match A interrupt.
 */
void setCallBack_CMPA_T1(void (*ptr2fun)(void))
{
    cmpMatchCallB_T1_1 = ptr2fun;
 14a:	90 93 00 00 	sts	0x0000, r25
 14e:	80 93 00 00 	sts	0x0000, r24
}
 152:	08 95       	ret

00000154 <setCallBack_CMPB_T1>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer1 compare match B interrupt.
 */
void setCallBack_CMPB_T1(void (*ptr2fun)(void))
{
    cmpMatchCallB_T1_2 = ptr2fun;
 154:	90 93 00 00 	sts	0x0000, r25
 158:	80 93 00 00 	sts	0x0000, r24
}
 15c:	08 95       	ret

0000015e <setCallBack_OV_T1>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer1 output compare interrupt.
 */
void setCallBack_OV_T1(void (*ptr2fun)(void))
{
    overFlowCallB_T1 = ptr2fun;
 15e:	90 93 00 00 	sts	0x0000, r25
 162:	80 93 00 00 	sts	0x0000, r24
}
 166:	08 95       	ret

00000168 <setCallBack_OV_T2>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer2 overflow interrupt.
 */
void setCallBack_OV_T2(void (*ptr2fun)(void))
{
    overFlowCallB_T2 = ptr2fun;
 168:	90 93 00 00 	sts	0x0000, r25
 16c:	80 93 00 00 	sts	0x0000, r24
}
 170:	08 95       	ret

00000172 <setCallBack_CMP_T2>:
 *
 * @param ptr2fun Pointer to the function to be called on Timer2 compare match interrupt.
 */
void setCallBack_CMP_T2(void (*ptr2fun)(void))
{
    cmpMatchCallB_T2 = ptr2fun;
 172:	90 93 00 00 	sts	0x0000, r25
 176:	80 93 00 00 	sts	0x0000, r24
}
 17a:	08 95       	ret

0000017c <__vector_4>:
/*********INTERRUPT SIGNAL HANDLERs**********/
/*****************TIMER2*******************/
/*Timer/Counter2 Compare Match*/
void __vector_4(void)  __attribute__((signal));
void __vector_4(void)
{
 17c:	1f 92       	push	r1
 17e:	0f 92       	push	r0
 180:	0f b6       	in	r0, 0x3f	; 63
 182:	0f 92       	push	r0
 184:	11 24       	eor	r1, r1
 186:	2f 93       	push	r18
 188:	3f 93       	push	r19
 18a:	4f 93       	push	r20
 18c:	5f 93       	push	r21
 18e:	6f 93       	push	r22
 190:	7f 93       	push	r23
 192:	8f 93       	push	r24
 194:	9f 93       	push	r25
 196:	af 93       	push	r26
 198:	bf 93       	push	r27
 19a:	ef 93       	push	r30
 19c:	ff 93       	push	r31
	cmpMatchCallB_T2();
 19e:	e0 91 00 00 	lds	r30, 0x0000
 1a2:	f0 91 00 00 	lds	r31, 0x0000
 1a6:	09 95       	icall
}
 1a8:	ff 91       	pop	r31
 1aa:	ef 91       	pop	r30
 1ac:	bf 91       	pop	r27
 1ae:	af 91       	pop	r26
 1b0:	9f 91       	pop	r25
 1b2:	8f 91       	pop	r24
 1b4:	7f 91       	pop	r23
 1b6:	6f 91       	pop	r22
 1b8:	5f 91       	pop	r21
 1ba:	4f 91       	pop	r20
 1bc:	3f 91       	pop	r19
 1be:	2f 91       	pop	r18
 1c0:	0f 90       	pop	r0
 1c2:	0f be       	out	0x3f, r0	; 63
 1c4:	0f 90       	pop	r0
 1c6:	1f 90       	pop	r1
 1c8:	18 95       	reti

000001ca <__vector_5>:
/*Timer/Counter2 Overflow*/
void __vector_5(void)  __attribute__((signal));
void __vector_5(void)
{
 1ca:	1f 92       	push	r1
 1cc:	0f 92       	push	r0
 1ce:	0f b6       	in	r0, 0x3f	; 63
 1d0:	0f 92       	push	r0
 1d2:	11 24       	eor	r1, r1
 1d4:	2f 93       	push	r18
 1d6:	3f 93       	push	r19
 1d8:	4f 93       	push	r20
 1da:	5f 93       	push	r21
 1dc:	6f 93       	push	r22
 1de:	7f 93       	push	r23
 1e0:	8f 93       	push	r24
 1e2:	9f 93       	push	r25
 1e4:	af 93       	push	r26
 1e6:	bf 93       	push	r27
 1e8:	ef 93       	push	r30
 1ea:	ff 93       	push	r31
	overFlowCallB_T2();
 1ec:	e0 91 00 00 	lds	r30, 0x0000
 1f0:	f0 91 00 00 	lds	r31, 0x0000
 1f4:	09 95       	icall
}
 1f6:	ff 91       	pop	r31
 1f8:	ef 91       	pop	r30
 1fa:	bf 91       	pop	r27
 1fc:	af 91       	pop	r26
 1fe:	9f 91       	pop	r25
 200:	8f 91       	pop	r24
 202:	7f 91       	pop	r23
 204:	6f 91       	pop	r22
 206:	5f 91       	pop	r21
 208:	4f 91       	pop	r20
 20a:	3f 91       	pop	r19
 20c:	2f 91       	pop	r18
 20e:	0f 90       	pop	r0
 210:	0f be       	out	0x3f, r0	; 63
 212:	0f 90       	pop	r0
 214:	1f 90       	pop	r1
 216:	18 95       	reti

00000218 <__vector_6>:

/*****************TIMER1*******************/
/*Timer/Counter1 Capture Event*/
void __vector_6(void)  __attribute__((signal));
void __vector_6(void)
{
 218:	1f 92       	push	r1
 21a:	0f 92       	push	r0
 21c:	0f b6       	in	r0, 0x3f	; 63
 21e:	0f 92       	push	r0
 220:	11 24       	eor	r1, r1
 222:	2f 93       	push	r18
 224:	3f 93       	push	r19
 226:	4f 93       	push	r20
 228:	5f 93       	push	r21
 22a:	6f 93       	push	r22
 22c:	7f 93       	push	r23
 22e:	8f 93       	push	r24
 230:	9f 93       	push	r25
 232:	af 93       	push	r26
 234:	bf 93       	push	r27
 236:	ef 93       	push	r30
 238:	ff 93       	push	r31
	cmpMatchCallB_T1_CEVENT();
 23a:	e0 91 00 00 	lds	r30, 0x0000
 23e:	f0 91 00 00 	lds	r31, 0x0000
 242:	09 95       	icall
}
 244:	ff 91       	pop	r31
 246:	ef 91       	pop	r30
 248:	bf 91       	pop	r27
 24a:	af 91       	pop	r26
 24c:	9f 91       	pop	r25
 24e:	8f 91       	pop	r24
 250:	7f 91       	pop	r23
 252:	6f 91       	pop	r22
 254:	5f 91       	pop	r21
 256:	4f 91       	pop	r20
 258:	3f 91       	pop	r19
 25a:	2f 91       	pop	r18
 25c:	0f 90       	pop	r0
 25e:	0f be       	out	0x3f, r0	; 63
 260:	0f 90       	pop	r0
 262:	1f 90       	pop	r1
 264:	18 95       	reti

00000266 <__vector_7>:
/*Timer/Counter1 Compare MatchA*/
void __vector_7(void)  __attribute__((signal));
void __vector_7(void)
{
 266:	1f 92       	push	r1
 268:	0f 92       	push	r0
 26a:	0f b6       	in	r0, 0x3f	; 63
 26c:	0f 92       	push	r0
 26e:	11 24       	eor	r1, r1
 270:	2f 93       	push	r18
 272:	3f 93       	push	r19
 274:	4f 93       	push	r20
 276:	5f 93       	push	r21
 278:	6f 93       	push	r22
 27a:	7f 93       	push	r23
 27c:	8f 93       	push	r24
 27e:	9f 93       	push	r25
 280:	af 93       	push	r26
 282:	bf 93       	push	r27
 284:	ef 93       	push	r30
 286:	ff 93       	push	r31
	cmpMatchCallB_T1_1();
 288:	e0 91 00 00 	lds	r30, 0x0000
 28c:	f0 91 00 00 	lds	r31, 0x0000
 290:	09 95       	icall
}
 292:	ff 91       	pop	r31
 294:	ef 91       	pop	r30
 296:	bf 91       	pop	r27
 298:	af 91       	pop	r26
 29a:	9f 91       	pop	r25
 29c:	8f 91       	pop	r24
 29e:	7f 91       	pop	r23
 2a0:	6f 91       	pop	r22
 2a2:	5f 91       	pop	r21
 2a4:	4f 91       	pop	r20
 2a6:	3f 91       	pop	r19
 2a8:	2f 91       	pop	r18
 2aa:	0f 90       	pop	r0
 2ac:	0f be       	out	0x3f, r0	; 63
 2ae:	0f 90       	pop	r0
 2b0:	1f 90       	pop	r1
 2b2:	18 95       	reti

000002b4 <__vector_8>:
/*Timer/Counter1 Compare MatchB*/
void __vector_8(void)  __attribute__((signal));
void __vector_8(void)
{
 2b4:	1f 92       	push	r1
 2b6:	0f 92       	push	r0
 2b8:	0f b6       	in	r0, 0x3f	; 63
 2ba:	0f 92       	push	r0
 2bc:	11 24       	eor	r1, r1
 2be:	2f 93       	push	r18
 2c0:	3f 93       	push	r19
 2c2:	4f 93       	push	r20
 2c4:	5f 93       	push	r21
 2c6:	6f 93       	push	r22
 2c8:	7f 93       	push	r23
 2ca:	8f 93       	push	r24
 2cc:	9f 93       	push	r25
 2ce:	af 93       	push	r26
 2d0:	bf 93       	push	r27
 2d2:	ef 93       	push	r30
 2d4:	ff 93       	push	r31
	cmpMatchCallB_T1_2();
 2d6:	e0 91 00 00 	lds	r30, 0x0000
 2da:	f0 91 00 00 	lds	r31, 0x0000
 2de:	09 95       	icall
}
 2e0:	ff 91       	pop	r31
 2e2:	ef 91       	pop	r30
 2e4:	bf 91       	pop	r27
 2e6:	af 91       	pop	r26
 2e8:	9f 91       	pop	r25
 2ea:	8f 91       	pop	r24
 2ec:	7f 91       	pop	r23
 2ee:	6f 91       	pop	r22
 2f0:	5f 91       	pop	r21
 2f2:	4f 91       	pop	r20
 2f4:	3f 91       	pop	r19
 2f6:	2f 91       	pop	r18
 2f8:	0f 90       	pop	r0
 2fa:	0f be       	out	0x3f, r0	; 63
 2fc:	0f 90       	pop	r0
 2fe:	1f 90       	pop	r1
 300:	18 95       	reti

00000302 <__vector_9>:
/*Timer/Counter1 Overflow*/
void __vector_9(void)  __attribute__((signal));
void __vector_9(void)
{
 302:	1f 92       	push	r1
 304:	0f 92       	push	r0
 306:	0f b6       	in	r0, 0x3f	; 63
 308:	0f 92       	push	r0
 30a:	11 24       	eor	r1, r1
 30c:	2f 93       	push	r18
 30e:	3f 93       	push	r19
 310:	4f 93       	push	r20
 312:	5f 93       	push	r21
 314:	6f 93       	push	r22
 316:	7f 93       	push	r23
 318:	8f 93       	push	r24
 31a:	9f 93       	push	r25
 31c:	af 93       	push	r26
 31e:	bf 93       	push	r27
 320:	ef 93       	push	r30
 322:	ff 93       	push	r31
    overFlowCallB_T1();
 324:	e0 91 00 00 	lds	r30, 0x0000
 328:	f0 91 00 00 	lds	r31, 0x0000
 32c:	09 95       	icall
}
 32e:	ff 91       	pop	r31
 330:	ef 91       	pop	r30
 332:	bf 91       	pop	r27
 334:	af 91       	pop	r26
 336:	9f 91       	pop	r25
 338:	8f 91       	pop	r24
 33a:	7f 91       	pop	r23
 33c:	6f 91       	pop	r22
 33e:	5f 91       	pop	r21
 340:	4f 91       	pop	r20
 342:	3f 91       	pop	r19
 344:	2f 91       	pop	r18
 346:	0f 90       	pop	r0
 348:	0f be       	out	0x3f, r0	; 63
 34a:	0f 90       	pop	r0
 34c:	1f 90       	pop	r1
 34e:	18 95       	reti

00000350 <__vector_10>:

/*****************TIMER0*******************/
/*Timer/Counter0 Compare Match*/
void __vector_10(void)  __attribute__((signal));
void __vector_10(void)
{
 350:	1f 92       	push	r1
 352:	0f 92       	push	r0
 354:	0f b6       	in	r0, 0x3f	; 63
 356:	0f 92       	push	r0
 358:	11 24       	eor	r1, r1
 35a:	2f 93       	push	r18
 35c:	3f 93       	push	r19
 35e:	4f 93       	push	r20
 360:	5f 93       	push	r21
 362:	6f 93       	push	r22
 364:	7f 93       	push	r23
 366:	8f 93       	push	r24
 368:	9f 93       	push	r25
 36a:	af 93       	push	r26
 36c:	bf 93       	push	r27
 36e:	ef 93       	push	r30
 370:	ff 93       	push	r31
	cmpMatchCallB_T0();
 372:	e0 91 00 00 	lds	r30, 0x0000
 376:	f0 91 00 00 	lds	r31, 0x0000
 37a:	09 95       	icall
    //SET_BIT(TIFR, OCF0);
}
 37c:	ff 91       	pop	r31
 37e:	ef 91       	pop	r30
 380:	bf 91       	pop	r27
 382:	af 91       	pop	r26
 384:	9f 91       	pop	r25
 386:	8f 91       	pop	r24
 388:	7f 91       	pop	r23
 38a:	6f 91       	pop	r22
 38c:	5f 91       	pop	r21
 38e:	4f 91       	pop	r20
 390:	3f 91       	pop	r19
 392:	2f 91       	pop	r18
 394:	0f 90       	pop	r0
 396:	0f be       	out	0x3f, r0	; 63
 398:	0f 90       	pop	r0
 39a:	1f 90       	pop	r1
 39c:	18 95       	reti

0000039e <__vector_11>:
/*Timer/Counter0 Overflow*/
void __vector_11(void)  __attribute__((signal));
void __vector_11(void)
{
 39e:	1f 92       	push	r1
 3a0:	0f 92       	push	r0
 3a2:	0f b6       	in	r0, 0x3f	; 63
 3a4:	0f 92       	push	r0
 3a6:	11 24       	eor	r1, r1
 3a8:	2f 93       	push	r18
 3aa:	3f 93       	push	r19
 3ac:	4f 93       	push	r20
 3ae:	5f 93       	push	r21
 3b0:	6f 93       	push	r22
 3b2:	7f 93       	push	r23
 3b4:	8f 93       	push	r24
 3b6:	9f 93       	push	r25
 3b8:	af 93       	push	r26
 3ba:	bf 93       	push	r27
 3bc:	ef 93       	push	r30
 3be:	ff 93       	push	r31
	overFlowCallB_T0();
 3c0:	e0 91 00 00 	lds	r30, 0x0000
 3c4:	f0 91 00 00 	lds	r31, 0x0000
 3c8:	09 95       	icall
    // SET_BIT(TIFR, TOV0);
}
 3ca:	ff 91       	pop	r31
 3cc:	ef 91       	pop	r30
 3ce:	bf 91       	pop	r27
 3d0:	af 91       	pop	r26
 3d2:	9f 91       	pop	r25
 3d4:	8f 91       	pop	r24
 3d6:	7f 91       	pop	r23
 3d8:	6f 91       	pop	r22
 3da:	5f 91       	pop	r21
 3dc:	4f 91       	pop	r20
 3de:	3f 91       	pop	r19
 3e0:	2f 91       	pop	r18
 3e2:	0f 90       	pop	r0
 3e4:	0f be       	out	0x3f, r0	; 63
 3e6:	0f 90       	pop	r0
 3e8:	1f 90       	pop	r1
 3ea:	18 95       	reti
